<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - MRS UAV System - Test coverage report - mrs_lib/include/mrs_lib/param_loader.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html" target="_parent">top level</a> - <a href="index.html" target="_parent">mrs_lib/include/mrs_lib</a> - param_loader.h<span style="font-size: 80%;"> (source / <a href="param_loader.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">MRS UAV System - Test coverage report</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">140</td>
            <td class="headerCovTableEntry">182</td>
            <td class="headerCovTableEntryMed">76.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2025-02-19 22:30:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">38</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntryHi">92.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // clang: MatousFormat</a>
<a name="2"><span class="lineNum">       2 </span>            : /**  \file</a>
<a name="3"><span class="lineNum">       3 </span>            :      \brief Defines ParamLoader - a convenience class for loading static ROS parameters.</a>
<a name="4"><span class="lineNum">       4 </span>            :      \author Matou≈° Vrba - vrbamato@fel.cvut.cz</a>
<a name="5"><span class="lineNum">       5 </span>            :  */</a>
<a name="6"><span class="lineNum">       6 </span>            : </a>
<a name="7"><span class="lineNum">       7 </span>            : #ifndef PARAM_LOADER_H</a>
<a name="8"><span class="lineNum">       8 </span>            : #define PARAM_LOADER_H</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : #include &lt;ros/ros.h&gt;</a>
<a name="11"><span class="lineNum">      11 </span>            : #include &lt;string&gt;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &lt;map&gt;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &lt;unordered_set&gt;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;iostream&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;Eigen/Dense&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : #include &lt;std_msgs/ColorRGBA.h&gt;</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &lt;mrs_lib/param_provider.h&gt;</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            : namespace mrs_lib</a>
<a name="20"><span class="lineNum">      20 </span>            : {</a>
<a name="21"><span class="lineNum">      21 </span>            : </a>
<a name="22"><span class="lineNum">      22 </span>            : /*** ParamLoader CLASS //{ **/</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : /**</a>
<a name="25"><span class="lineNum">      25 </span>            : * \brief Convenience class for loading parameters from rosparam server.</a>
<a name="26"><span class="lineNum">      26 </span>            : *</a>
<a name="27"><span class="lineNum">      27 </span>            : * The parameters can be loaded as compulsory. If a compulsory parameter is not found</a>
<a name="28"><span class="lineNum">      28 </span>            : * on the rosparam server (e.g. because it is missing in the launchfile or the yaml config file),</a>
<a name="29"><span class="lineNum">      29 </span>            : * an internal flag is set to false, indicating that the parameter loading procedure failed.</a>
<a name="30"><span class="lineNum">      30 </span>            : * This flag can be checked using the loaded_successfully() method after all parameters were</a>
<a name="31"><span class="lineNum">      31 </span>            : * attempted to be loaded (see usage example usage below).</a>
<a name="32"><span class="lineNum">      32 </span>            : *</a>
<a name="33"><span class="lineNum">      33 </span>            : * The loaded parameter names and corresponding values are printed to stdout by default</a>
<a name="34"><span class="lineNum">      34 </span>            : * for user convenience. Special cases such as loading of Eigen matrices or loading</a>
<a name="35"><span class="lineNum">      35 </span>            : * of std::vectors of various values are also provided.</a>
<a name="36"><span class="lineNum">      36 </span>            : *</a>
<a name="37"><span class="lineNum">      37 </span>            : * To load parameters into the `rosparam` server, use a launchfile prefferably.</a>
<a name="38"><span class="lineNum">      38 </span>            : * See documentation of ROS launchfiles here: http://wiki.ros.org/roslaunch/XML.</a>
<a name="39"><span class="lineNum">      39 </span>            : * Specifically, the `param` XML tag is used for loading parameters directly from the launchfile: http://wiki.ros.org/roslaunch/XML/param,</a>
<a name="40"><span class="lineNum">      40 </span>            : * and the `rosparam` XML tag tag is used for loading parameters from a `yaml` file: http://wiki.ros.org/roslaunch/XML/rosparam.</a>
<a name="41"><span class="lineNum">      41 </span>            : *</a>
<a name="42"><span class="lineNum">      42 </span>            : */</a>
<a name="43"><span class="lineNum">      43 </span>            : class ParamLoader</a>
<a name="44"><span class="lineNum">      44 </span>            : {</a>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<a name="46"><span class="lineNum">      46 </span>            : private:</a>
<a name="47"><span class="lineNum">      47 </span>            :   enum unique_t</a>
<a name="48"><span class="lineNum">      48 </span>            :   {</a>
<a name="49"><span class="lineNum">      49 </span>            :     UNIQUE = true,</a>
<a name="50"><span class="lineNum">      50 </span>            :     REUSABLE = false</a>
<a name="51"><span class="lineNum">      51 </span>            :   };</a>
<a name="52"><span class="lineNum">      52 </span>            :   enum optional_t</a>
<a name="53"><span class="lineNum">      53 </span>            :   {</a>
<a name="54"><span class="lineNum">      54 </span>            :     OPTIONAL = true,</a>
<a name="55"><span class="lineNum">      55 </span>            :     COMPULSORY = false</a>
<a name="56"><span class="lineNum">      56 </span>            :   };</a>
<a name="57"><span class="lineNum">      57 </span>            :   enum swap_t</a>
<a name="58"><span class="lineNum">      58 </span>            :   {</a>
<a name="59"><span class="lineNum">      59 </span>            :     SWAP = true,</a>
<a name="60"><span class="lineNum">      60 </span>            :     NO_SWAP = false</a>
<a name="61"><span class="lineNum">      61 </span>            :   };</a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            :   template &lt;typename T&gt;</a>
<a name="64"><span class="lineNum">      64 </span>            :   using MatrixX = Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt;;</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            : private:</a>
<a name="67"><span class="lineNum">      67 </span>            :   bool m_load_successful, m_print_values;</a>
<a name="68"><span class="lineNum">      68 </span>            :   std::string m_node_name;</a>
<a name="69"><span class="lineNum">      69 </span>            :   std::string m_prefix;</a>
<a name="70"><span class="lineNum">      70 </span>            :   ros::NodeHandle m_nh;</a>
<a name="71"><span class="lineNum">      71 </span>            :   mrs_lib::ParamProvider m_pp;</a>
<a name="72"><span class="lineNum">      72 </span>            :   std::unordered_set&lt;std::string&gt; m_loaded_params;</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            :   /* printing helper functions //{ */</a>
<a name="75"><span class="lineNum">      75 </span>            :   /* printError and print_warning functions //{*/</a>
<a name="76"><span class="lineNum">      76 </span><span class="lineNoCov">          0 :   void printError(const std::string&amp; str)</span></a>
<a name="77"><span class="lineNum">      77 </span>            :   {</a>
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 :     if (m_node_name.empty())</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineNoCov">          0 :       ROS_ERROR_STREAM(str);</span></a>
<a name="80"><span class="lineNum">      80 </span>            :     else</a>
<a name="81"><span class="lineNum">      81 </span><span class="lineNoCov">          0 :       ROS_ERROR_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: &quot; &lt;&lt; str);</span></a>
<a name="82"><span class="lineNum">      82 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="83"><span class="lineNum">      83 </span><span class="lineNoCov">          0 :   void print_warning(const std::string&amp; str)</span></a>
<a name="84"><span class="lineNum">      84 </span>            :   {</a>
<a name="85"><span class="lineNum">      85 </span><span class="lineNoCov">          0 :     if (m_node_name.empty())</span></a>
<a name="86"><span class="lineNum">      86 </span><span class="lineNoCov">          0 :       ROS_WARN_STREAM(str);</span></a>
<a name="87"><span class="lineNum">      87 </span>            :     else</a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :       ROS_WARN_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: &quot; &lt;&lt; str);</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineNoCov">          0 :   }</span></a>
<a name="90"><span class="lineNum">      90 </span>            :   //}</a>
<a name="91"><span class="lineNum">      91 </span>            : </a>
<a name="92"><span class="lineNum">      92 </span>            :   /* printValue function and overloads //{ */</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :   template &lt;typename T&gt;</a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">      38590 :   void printValue(const std::string&amp; name, const T&amp; value)</span></a>
<a name="96"><span class="lineNum">      96 </span>            :   {</a>
<a name="97"><span class="lineNum">      97 </span><span class="lineCov">      38590 :     if (m_node_name.empty())</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineCov">      21207 :       std::cout &lt;&lt; &quot;\t&quot; &lt;&lt; name &lt;&lt; &quot;:\t&quot; &lt;&lt; value &lt;&lt; std::endl;</span></a>
<a name="99"><span class="lineNum">      99 </span>            :     else</a>
<a name="100"><span class="lineNum">     100 </span><span class="lineCov">      17383 :       ROS_INFO_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: parameter '&quot; &lt;&lt; name &lt;&lt; &quot;':\t&quot; &lt;&lt; value);</span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineCov">      38590 :   }</span></a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            :   template &lt;typename T&gt;</a>
<a name="104"><span class="lineNum">     104 </span><span class="lineCov">       2186 :   void printValue(const std::string&amp; name, const std::vector&lt;T&gt;&amp; value)</span></a>
<a name="105"><span class="lineNum">     105 </span>            :   {</a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">       4372 :     std::stringstream strstr;</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">       2186 :     if (m_node_name.empty())</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineCov">       1046 :       strstr &lt;&lt; &quot;\t&quot;;</span></a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">       2186 :     strstr &lt;&lt; name &lt;&lt; &quot;:\t&quot;;</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineCov">       2186 :     size_t it = 0;</span></a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">       7615 :     for (const auto&amp; elem : value)</span></a>
<a name="112"><span class="lineNum">     112 </span>            :     {</a>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">       5429 :       strstr &lt;&lt; elem;</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">       5429 :       if (it &lt; value.size() - 1)</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineCov">       3490 :         strstr &lt;&lt; &quot;, &quot;;</span></a>
<a name="116"><span class="lineNum">     116 </span><span class="lineCov">       5429 :       it++;</span></a>
<a name="117"><span class="lineNum">     117 </span>            :     }</a>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">       2186 :     if (m_node_name.empty())</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">       1046 :       std::cout &lt;&lt; strstr.str() &lt;&lt; std::endl;</span></a>
<a name="120"><span class="lineNum">     120 </span>            :     else</a>
<a name="121"><span class="lineNum">     121 </span><span class="lineCov">       1140 :       ROS_INFO_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: parameter '&quot; &lt;&lt; strstr.str());</span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">       2186 :   }</span></a>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<a name="124"><span class="lineNum">     124 </span>            :   template &lt;typename T1, typename T2&gt;</a>
<a name="125"><span class="lineNum">     125 </span>            :   void printValue(const std::string&amp; name, const std::map&lt;T1, T2&gt;&amp; value)</a>
<a name="126"><span class="lineNum">     126 </span>            :   {</a>
<a name="127"><span class="lineNum">     127 </span>            :     std::stringstream strstr;</a>
<a name="128"><span class="lineNum">     128 </span>            :     if (m_node_name.empty())</a>
<a name="129"><span class="lineNum">     129 </span>            :       strstr &lt;&lt; &quot;\t&quot;;</a>
<a name="130"><span class="lineNum">     130 </span>            :     strstr &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; std::endl;</a>
<a name="131"><span class="lineNum">     131 </span>            :     size_t it = 0;</a>
<a name="132"><span class="lineNum">     132 </span>            :     for (const auto&amp; pair : value)</a>
<a name="133"><span class="lineNum">     133 </span>            :     {</a>
<a name="134"><span class="lineNum">     134 </span>            :       strstr &lt;&lt; pair.first &lt;&lt; &quot; = &quot; &lt;&lt; pair.second;</a>
<a name="135"><span class="lineNum">     135 </span>            :       if (it &lt; value.size() - 1)</a>
<a name="136"><span class="lineNum">     136 </span>            :         strstr &lt;&lt; std::endl;</a>
<a name="137"><span class="lineNum">     137 </span>            :       it++;</a>
<a name="138"><span class="lineNum">     138 </span>            :     }</a>
<a name="139"><span class="lineNum">     139 </span>            :     if (m_node_name.empty())</a>
<a name="140"><span class="lineNum">     140 </span>            :       std::cout &lt;&lt; strstr.str() &lt;&lt; std::endl;</a>
<a name="141"><span class="lineNum">     141 </span>            :     else</a>
<a name="142"><span class="lineNum">     142 </span>            :       ROS_INFO_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: parameter '&quot; &lt;&lt; strstr.str());</a>
<a name="143"><span class="lineNum">     143 </span>            :   }</a>
<a name="144"><span class="lineNum">     144 </span>            : </a>
<a name="145"><span class="lineNum">     145 </span>            :   template &lt;typename T&gt;</a>
<a name="146"><span class="lineNum">     146 </span><span class="lineCov">        317 :   void printValue(const std::string&amp; name, const MatrixX&lt;T&gt;&amp; value)</span></a>
<a name="147"><span class="lineNum">     147 </span>            :   {</a>
<a name="148"><span class="lineNum">     148 </span><span class="lineCov">        634 :     std::stringstream strstr;</span></a>
<a name="149"><span class="lineNum">     149 </span>            :     /* const Eigen::IOFormat fmt(4, 0, &quot;, &quot;, &quot;\n&quot;, &quot;\t\t[&quot;, &quot;]&quot;); */</a>
<a name="150"><span class="lineNum">     150 </span>            :     /* strstr &lt;&lt; value.format(fmt); */</a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">        951 :     const Eigen::IOFormat fmt;</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">        317 :     strstr &lt;&lt; value.format(fmt);</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">        317 :     if (m_node_name.empty())</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineCov">         35 :       std::cout &lt;&lt; &quot;\t&quot; &lt;&lt; name &lt;&lt; &quot;:\t&quot; &lt;&lt; std::endl &lt;&lt; strstr.str() &lt;&lt; std::endl;</span></a>
<a name="155"><span class="lineNum">     155 </span>            :     else</a>
<a name="156"><span class="lineNum">     156 </span><span class="lineCov">        282 :       ROS_INFO_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: parameter '&quot; &lt;&lt; name &lt;&lt; &quot;':&quot; &lt;&lt; std::endl &lt;&lt; strstr.str());</span></a>
<a name="157"><span class="lineNum">     157 </span><span class="lineCov">        317 :   }</span></a>
<a name="158"><span class="lineNum">     158 </span>            : </a>
<a name="159"><span class="lineNum">     159 </span>            :   std::string printValue_recursive(const std::string&amp; name, XmlRpc::XmlRpcValue&amp; value, unsigned depth = 0)</a>
<a name="160"><span class="lineNum">     160 </span>            :   {</a>
<a name="161"><span class="lineNum">     161 </span>            :     std::stringstream strstr;</a>
<a name="162"><span class="lineNum">     162 </span>            :     for (unsigned it = 0; it &lt; depth; it++)</a>
<a name="163"><span class="lineNum">     163 </span>            :       strstr &lt;&lt; &quot;\t&quot;;</a>
<a name="164"><span class="lineNum">     164 </span>            :     strstr &lt;&lt; name &lt;&lt; &quot;:&quot;;</a>
<a name="165"><span class="lineNum">     165 </span>            :     switch (value.getType())</a>
<a name="166"><span class="lineNum">     166 </span>            :     {</a>
<a name="167"><span class="lineNum">     167 </span>            :       case XmlRpc::XmlRpcValue::TypeArray:</a>
<a name="168"><span class="lineNum">     168 </span>            :         {</a>
<a name="169"><span class="lineNum">     169 </span>            :           for (int it = 0; it &lt; value.size(); it++)</a>
<a name="170"><span class="lineNum">     170 </span>            :           {</a>
<a name="171"><span class="lineNum">     171 </span>            :             strstr &lt;&lt; std::endl;</a>
<a name="172"><span class="lineNum">     172 </span>            :             const std::string name = &quot;[&quot; + std::to_string(it) + &quot;]&quot;;</a>
<a name="173"><span class="lineNum">     173 </span>            :             strstr &lt;&lt; printValue_recursive(name, value[it], depth+1);</a>
<a name="174"><span class="lineNum">     174 </span>            :           }</a>
<a name="175"><span class="lineNum">     175 </span>            :           break;</a>
<a name="176"><span class="lineNum">     176 </span>            :         }</a>
<a name="177"><span class="lineNum">     177 </span>            :       case XmlRpc::XmlRpcValue::TypeStruct:</a>
<a name="178"><span class="lineNum">     178 </span>            :         {</a>
<a name="179"><span class="lineNum">     179 </span>            :           int it = 0;</a>
<a name="180"><span class="lineNum">     180 </span>            :           for (auto&amp; pair : value)</a>
<a name="181"><span class="lineNum">     181 </span>            :           {</a>
<a name="182"><span class="lineNum">     182 </span>            :             strstr &lt;&lt; std::endl;</a>
<a name="183"><span class="lineNum">     183 </span>            :             strstr &lt;&lt; printValue_recursive(pair.first, pair.second, depth+1);</a>
<a name="184"><span class="lineNum">     184 </span>            :             it++;</a>
<a name="185"><span class="lineNum">     185 </span>            :           }</a>
<a name="186"><span class="lineNum">     186 </span>            :           break;</a>
<a name="187"><span class="lineNum">     187 </span>            :         }</a>
<a name="188"><span class="lineNum">     188 </span>            :       default:</a>
<a name="189"><span class="lineNum">     189 </span>            :         {</a>
<a name="190"><span class="lineNum">     190 </span>            :           strstr &lt;&lt; &quot;\t&quot; &lt;&lt; value;</a>
<a name="191"><span class="lineNum">     191 </span>            :           break;</a>
<a name="192"><span class="lineNum">     192 </span>            :         }</a>
<a name="193"><span class="lineNum">     193 </span>            :     }</a>
<a name="194"><span class="lineNum">     194 </span>            :     return strstr.str();</a>
<a name="195"><span class="lineNum">     195 </span>            :   }</a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            :   void printValue(const std::string&amp; name, XmlRpc::XmlRpcValue&amp; value)</a>
<a name="198"><span class="lineNum">     198 </span>            :   {</a>
<a name="199"><span class="lineNum">     199 </span>            :     const std::string txt = printValue_recursive(name, value);</a>
<a name="200"><span class="lineNum">     200 </span>            :     if (m_node_name.empty())</a>
<a name="201"><span class="lineNum">     201 </span>            :       std::cout &lt;&lt; txt &lt;&lt; std::endl;</a>
<a name="202"><span class="lineNum">     202 </span>            :     else</a>
<a name="203"><span class="lineNum">     203 </span>            :       ROS_INFO_STREAM(&quot;[&quot; &lt;&lt; m_node_name &lt;&lt; &quot;]: parameter '&quot; &lt;&lt; txt);</a>
<a name="204"><span class="lineNum">     204 </span>            :   }</a>
<a name="205"><span class="lineNum">     205 </span>            : </a>
<a name="206"><span class="lineNum">     206 </span>            :   //}</a>
<a name="207"><span class="lineNum">     207 </span>            :   </a>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 :   std::string resolved(const std::string&amp; param_name)</span></a>
<a name="209"><span class="lineNum">     209 </span>            :   {</a>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :     return m_nh.resolveName(param_name);</span></a>
<a name="211"><span class="lineNum">     211 </span>            :   }</a>
<a name="212"><span class="lineNum">     212 </span>            :   //}</a>
<a name="213"><span class="lineNum">     213 </span>            : </a>
<a name="214"><span class="lineNum">     214 </span>            :   /* check_duplicit_loading checks whether the parameter was already loaded - returns true if yes //{ */</a>
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">      41097 :   bool check_duplicit_loading(const std::string&amp; name)</span></a>
<a name="216"><span class="lineNum">     216 </span>            :   {</a>
<a name="217"><span class="lineNum">     217 </span><span class="lineCov">      41097 :     if (m_loaded_params.count(name))</span></a>
<a name="218"><span class="lineNum">     218 </span>            :     {</a>
<a name="219"><span class="lineNum">     219 </span><span class="lineNoCov">          0 :       printError(std::string(&quot;Tried to load parameter &quot;) + name + std::string(&quot; twice&quot;));</span></a>
<a name="220"><span class="lineNum">     220 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="221"><span class="lineNum">     221 </span><span class="lineNoCov">          0 :       return true;</span></a>
<a name="222"><span class="lineNum">     222 </span>            :     } else</a>
<a name="223"><span class="lineNum">     223 </span>            :     {</a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">      41097 :       return false;</span></a>
<a name="225"><span class="lineNum">     225 </span>            :     }</a>
<a name="226"><span class="lineNum">     226 </span>            :   }</a>
<a name="227"><span class="lineNum">     227 </span>            :   //}</a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span>            :   /* helper functions for loading dynamic Eigen matrices //{ */</a>
<a name="230"><span class="lineNum">     230 </span>            :   // loadMatrixX helper function for loading dynamic Eigen matrices //{</a>
<a name="231"><span class="lineNum">     231 </span>            :   template &lt;typename T&gt;</a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">        317 :   std::pair&lt;MatrixX&lt;T&gt;, bool&gt; loadMatrixX(const std::string&amp; name, const MatrixX&lt;T&gt;&amp; default_value, int rows, int cols = Eigen::Dynamic, optional_t optional = OPTIONAL, unique_t unique = UNIQUE, swap_t swap = NO_SWAP, bool printValues = true)</span></a>
<a name="233"><span class="lineNum">     233 </span>            :   {</a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">        634 :     const std::string name_prefixed = m_prefix + name;</span></a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">        634 :     MatrixX&lt;T&gt; loaded = default_value;</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">        317 :     bool used_rosparam_value = false;</span></a>
<a name="237"><span class="lineNum">     237 </span>            :     // first, check if the user already tried to load this parameter</a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">        317 :     if (unique &amp;&amp; check_duplicit_loading(name_prefixed))</span></a>
<a name="239"><span class="lineNum">     239 </span><span class="lineNoCov">          0 :       return {loaded, used_rosparam_value};</span></a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            :     // this function only accepts dynamic columns (you can always transpose the matrix afterward)</a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">        317 :     if (rows &lt; 0)</span></a>
<a name="243"><span class="lineNum">     243 </span>            :     {</a>
<a name="244"><span class="lineNum">     244 </span>            :       // if the parameter was compulsory, alert the user and set the flag</a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :       printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name_prefixed));</span></a>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :       return {loaded, used_rosparam_value};</span></a>
<a name="248"><span class="lineNum">     248 </span>            :     }</a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">        317 :     const bool expect_zero_matrix = rows == 0;</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">        317 :     if (expect_zero_matrix)</span></a>
<a name="251"><span class="lineNum">     251 </span>            :     {</a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :       if (cols &gt; 0)</span></a>
<a name="253"><span class="lineNum">     253 </span>            :       {</a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :         printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name_prefixed) + &quot;. One dimension indicates zero matrix, but other expects non-zero.&quot;);</span></a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :         m_load_successful = false;</span></a>
<a name="256"><span class="lineNum">     256 </span><span class="lineNoCov">          0 :         return {loaded, used_rosparam_value};</span></a>
<a name="257"><span class="lineNum">     257 </span>            :       }</a>
<a name="258"><span class="lineNum">     258 </span>            :     }</a>
<a name="259"><span class="lineNum">     259 </span>            : </a>
<a name="260"><span class="lineNum">     260 </span><span class="lineCov">        317 :     bool cur_load_successful = true;</span></a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">        317 :     bool check_size_exact = true;</span></a>
<a name="262"><span class="lineNum">     262 </span><span class="lineCov">        317 :     if (cols &lt;= 0)  // this means that the cols dimension is dynamic or a zero matrix is expected</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">         82 :       check_size_exact = false;</span></a>
<a name="264"><span class="lineNum">     264 </span>            : </a>
<a name="265"><span class="lineNum">     265 </span><span class="lineCov">        634 :     std::vector&lt;T&gt; tmp_vec;</span></a>
<a name="266"><span class="lineNum">     266 </span>            :     // try to load the parameter</a>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">        317 :     const bool success = m_pp.getParam(name_prefixed, tmp_vec);</span></a>
<a name="268"><span class="lineNum">     268 </span>            :     // check if the loaded vector has correct length</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineCov">        317 :     bool correct_size = (int)tmp_vec.size() == rows * cols;</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">        317 :     if (!check_size_exact &amp;&amp; !expect_zero_matrix)</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineCov">         82 :       correct_size = (int)tmp_vec.size() % rows == 0;  // if the cols dimension is dynamic, the size just has to be divisable by rows</span></a>
<a name="272"><span class="lineNum">     272 </span>            : </a>
<a name="273"><span class="lineNum">     273 </span><span class="lineCov">        317 :     if (success &amp;&amp; correct_size)</span></a>
<a name="274"><span class="lineNum">     274 </span>            :     {</a>
<a name="275"><span class="lineNum">     275 </span>            :       // if successfully loaded, everything is in order</a>
<a name="276"><span class="lineNum">     276 </span>            :       // transform the vector to the matrix</a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">        270 :       if (cols &lt;= 0 &amp;&amp; rows &gt; 0)</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">         82 :         cols = tmp_vec.size() / rows;</span></a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">        270 :       if (swap)</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">         35 :         std::swap(rows, cols);</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineCov">        270 :       loaded = Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::Unaligned&gt;(tmp_vec.data(), rows, cols);</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineCov">        270 :       used_rosparam_value = true;</span></a>
<a name="283"><span class="lineNum">     283 </span>            :     } else</a>
<a name="284"><span class="lineNum">     284 </span>            :     {</a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">         47 :       if (success &amp;&amp; !correct_size)</span></a>
<a name="286"><span class="lineNum">     286 </span>            :       {</a>
<a name="287"><span class="lineNum">     287 </span>            :         // warn the user that this parameter was not successfully loaded because of wrong vector length (might be an oversight)</a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :         std::string warning =</span></a>
<a name="289"><span class="lineNum">     289 </span>            :             std::string(&quot;Matrix parameter &quot;) + name_prefixed</a>
<a name="290"><span class="lineNum">     290 </span>            :             + std::string(&quot; could not be loaded because the vector has a wrong length &quot; + std::to_string(tmp_vec.size()) + &quot; instead of expected &quot;);</a>
<a name="291"><span class="lineNum">     291 </span>            :         // process the message correctly based on whether the loaded matrix should be dynamic or static</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineNoCov">          0 :         if (cols &lt;= 0)  // for dynamic matrices</span></a>
<a name="293"><span class="lineNum">     293 </span><span class="lineNoCov">          0 :           warning = warning + std::string(&quot;number divisible by &quot;) + std::to_string(rows);</span></a>
<a name="294"><span class="lineNum">     294 </span>            :         else  // for static matrices</a>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 :           warning = warning + std::to_string(rows * cols);</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :         print_warning(warning);</span></a>
<a name="297"><span class="lineNum">     297 </span>            :       }</a>
<a name="298"><span class="lineNum">     298 </span>            :       // if it was not loaded, the default value is used (set at the beginning of the function)</a>
<a name="299"><span class="lineNum">     299 </span><span class="lineCov">         47 :       if (!optional)</span></a>
<a name="300"><span class="lineNum">     300 </span>            :       {</a>
<a name="301"><span class="lineNum">     301 </span>            :         // if the parameter was compulsory, alert the user and set the flag</a>
<a name="302"><span class="lineNum">     302 </span><span class="lineNoCov">          0 :         printError(std::string(&quot;Could not load non-optional parameter &quot;) + resolved(name_prefixed));</span></a>
<a name="303"><span class="lineNum">     303 </span><span class="lineNoCov">          0 :         cur_load_successful = false;</span></a>
<a name="304"><span class="lineNum">     304 </span>            :       }</a>
<a name="305"><span class="lineNum">     305 </span>            :     }</a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span>            :     // check if load was a success</a>
<a name="308"><span class="lineNum">     308 </span><span class="lineCov">        317 :     if (cur_load_successful)</span></a>
<a name="309"><span class="lineNum">     309 </span>            :     {</a>
<a name="310"><span class="lineNum">     310 </span><span class="lineCov">        317 :       if (m_print_values &amp;&amp; printValues)</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineCov">        317 :         printValue(name_prefixed, loaded);</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">        317 :       m_loaded_params.insert(name_prefixed);</span></a>
<a name="313"><span class="lineNum">     313 </span>            :     } else</a>
<a name="314"><span class="lineNum">     314 </span>            :     {</a>
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="316"><span class="lineNum">     316 </span>            :     }</a>
<a name="317"><span class="lineNum">     317 </span>            :     // finally, return the resulting value</a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">        317 :     return {loaded, used_rosparam_value};</span></a>
<a name="319"><span class="lineNum">     319 </span>            :   }</a>
<a name="320"><span class="lineNum">     320 </span>            :   //}</a>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<a name="322"><span class="lineNum">     322 </span>            :   /* loadMatrixStatic_internal helper function for loading static Eigen matrices //{ */</a>
<a name="323"><span class="lineNum">     323 </span>            :   template &lt;int rows, int cols, typename T&gt;</a>
<a name="324"><span class="lineNum">     324 </span><span class="lineCov">         47 :   std::pair&lt;Eigen::Matrix&lt;T, rows, cols&gt;, bool&gt; loadMatrixStatic_internal(const std::string&amp; name, const Eigen::Matrix&lt;T, rows, cols&gt;&amp; default_value, optional_t optional, unique_t unique)</span></a>
<a name="325"><span class="lineNum">     325 </span>            :   {</a>
<a name="326"><span class="lineNum">     326 </span><span class="lineCov">        141 :     const auto [dynamic, loaded_ok] = loadMatrixX(name, MatrixX&lt;T&gt;(default_value), rows, cols, optional, unique, NO_SWAP);</span></a>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">         94 :     return {dynamic, loaded_ok};</span></a>
<a name="328"><span class="lineNum">     328 </span>            :   }</a>
<a name="329"><span class="lineNum">     329 </span>            :   //}</a>
<a name="330"><span class="lineNum">     330 </span>            : </a>
<a name="331"><span class="lineNum">     331 </span>            :   /* loadMatrixKnown_internal helper function for loading EigenXd matrices with known dimensions //{ */</a>
<a name="332"><span class="lineNum">     332 </span>            :   template &lt;typename T&gt;</a>
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">        188 :   std::pair&lt;MatrixX&lt;T&gt;, bool&gt; loadMatrixKnown_internal(const std::string&amp; name, const MatrixX&lt;T&gt;&amp; default_value, int rows, int cols, optional_t optional, unique_t unique)</span></a>
<a name="334"><span class="lineNum">     334 </span>            :   {</a>
<a name="335"><span class="lineNum">     335 </span><span class="lineCov">        376 :     MatrixX&lt;T&gt; loaded = default_value;</span></a>
<a name="336"><span class="lineNum">     336 </span>            :     // first, check that at least one dimension is set</a>
<a name="337"><span class="lineNum">     337 </span><span class="lineCov">        188 :     if (rows &lt;= 0 || cols &lt;= 0)</span></a>
<a name="338"><span class="lineNum">     338 </span>            :     {</a>
<a name="339"><span class="lineNum">     339 </span><span class="lineNoCov">          0 :       printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name) + std::string(&quot; (use loadMatrixDynamic?)&quot;));</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :       return {loaded, false};</span></a>
<a name="342"><span class="lineNum">     342 </span>            :     }</a>
<a name="343"><span class="lineNum">     343 </span>            : </a>
<a name="344"><span class="lineNum">     344 </span><span class="lineCov">        188 :     return loadMatrixX(name, default_value, rows, cols, optional, unique, NO_SWAP);</span></a>
<a name="345"><span class="lineNum">     345 </span>            :   }</a>
<a name="346"><span class="lineNum">     346 </span>            :   //}</a>
<a name="347"><span class="lineNum">     347 </span>            : </a>
<a name="348"><span class="lineNum">     348 </span>            :   /* loadMatrixDynamic_internal helper function for loading Eigen matrices with one dynamic (unspecified) dimension //{ */</a>
<a name="349"><span class="lineNum">     349 </span>            :   template &lt;typename T&gt;</a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">         82 :   std::pair&lt;MatrixX&lt;T&gt;, bool&gt; loadMatrixDynamic_internal(const std::string&amp; name, const MatrixX&lt;T&gt;&amp; default_value, int rows, int cols, optional_t optional, unique_t unique)</span></a>
<a name="351"><span class="lineNum">     351 </span>            :   {</a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">        164 :     MatrixX&lt;T&gt; loaded = default_value;</span></a>
<a name="353"><span class="lineNum">     353 </span>            : </a>
<a name="354"><span class="lineNum">     354 </span>            :     // next, check that at least one dimension is set</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">         82 :     if (rows &lt;= 0 &amp;&amp; cols &lt;= 0)</span></a>
<a name="356"><span class="lineNum">     356 </span>            :     {</a>
<a name="357"><span class="lineNum">     357 </span><span class="lineNoCov">          0 :       printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name) + std::string(&quot; (at least one dimension must be specified)&quot;));</span></a>
<a name="358"><span class="lineNum">     358 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :       return {loaded, false};</span></a>
<a name="360"><span class="lineNum">     360 </span>            :     }</a>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">         82 :     swap_t swap = NO_SWAP;</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">         82 :     if (rows &lt;= 0)</span></a>
<a name="364"><span class="lineNum">     364 </span>            :     {</a>
<a name="365"><span class="lineNum">     365 </span><span class="lineCov">         35 :       std::swap(rows, cols);</span></a>
<a name="366"><span class="lineNum">     366 </span><span class="lineCov">         35 :       swap = SWAP;</span></a>
<a name="367"><span class="lineNum">     367 </span>            :     }</a>
<a name="368"><span class="lineNum">     368 </span><span class="lineCov">         82 :     return loadMatrixX(name, default_value, rows, cols, optional, unique, swap);</span></a>
<a name="369"><span class="lineNum">     369 </span>            :   }</a>
<a name="370"><span class="lineNum">     370 </span>            :   //}</a>
<a name="371"><span class="lineNum">     371 </span>            :   //}</a>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<a name="373"><span class="lineNum">     373 </span>            :   /* loadMatrixArray_internal helper function for loading an array of EigenXd matrices with known dimensions //{ */</a>
<a name="374"><span class="lineNum">     374 </span>            :   template &lt;typename T&gt;</a>
<a name="375"><span class="lineNum">     375 </span>            :   std::vector&lt;MatrixX&lt;T&gt;&gt; loadMatrixArray_internal(const std::string&amp; name, const std::vector&lt;MatrixX&lt;T&gt;&gt;&amp; default_value, optional_t optional, unique_t unique)</a>
<a name="376"><span class="lineNum">     376 </span>            :   {</a>
<a name="377"><span class="lineNum">     377 </span>            :     const std::string name_prefixed = m_prefix + name;</a>
<a name="378"><span class="lineNum">     378 </span>            :     int rows;</a>
<a name="379"><span class="lineNum">     379 </span>            :     std::vector&lt;int&gt; cols;</a>
<a name="380"><span class="lineNum">     380 </span>            :     bool success = true;</a>
<a name="381"><span class="lineNum">     381 </span>            :     success = success &amp;&amp; m_pp.getParam(name_prefixed + &quot;/rows&quot;, rows);</a>
<a name="382"><span class="lineNum">     382 </span>            :     success = success &amp;&amp; m_pp.getParam(name_prefixed + &quot;/cols&quot;, cols);</a>
<a name="383"><span class="lineNum">     383 </span>            : </a>
<a name="384"><span class="lineNum">     384 </span>            :     std::vector&lt;MatrixX&lt;T&gt;&gt; loaded;</a>
<a name="385"><span class="lineNum">     385 </span>            :     loaded.reserve(cols.size());</a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span>            :     int total_cols = 0;</a>
<a name="388"><span class="lineNum">     388 </span>            :     /* check correctness of loaded parameters so far calculate the total dimension //{ */</a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span>            :     if (!success)</a>
<a name="391"><span class="lineNum">     391 </span>            :     {</a>
<a name="392"><span class="lineNum">     392 </span>            :       printError(std::string(&quot;Failed to load &quot;) + resolved(name_prefixed) + std::string(&quot;/rows or &quot;) + resolved(name_prefixed) + std::string(&quot;/cols&quot;));</a>
<a name="393"><span class="lineNum">     393 </span>            :       m_load_successful = false;</a>
<a name="394"><span class="lineNum">     394 </span>            :       return default_value;</a>
<a name="395"><span class="lineNum">     395 </span>            :     }</a>
<a name="396"><span class="lineNum">     396 </span>            :     if (rows &lt; 0)</a>
<a name="397"><span class="lineNum">     397 </span>            :     {</a>
<a name="398"><span class="lineNum">     398 </span>            :       printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name_prefixed) + std::string(&quot; (rows and cols must be &gt;= 0)&quot;));</a>
<a name="399"><span class="lineNum">     399 </span>            :       m_load_successful = false;</a>
<a name="400"><span class="lineNum">     400 </span>            :       return default_value;</a>
<a name="401"><span class="lineNum">     401 </span>            :     }</a>
<a name="402"><span class="lineNum">     402 </span>            :     for (const auto&amp; col : cols)</a>
<a name="403"><span class="lineNum">     403 </span>            :     {</a>
<a name="404"><span class="lineNum">     404 </span>            :       if (col &lt; 0)</a>
<a name="405"><span class="lineNum">     405 </span>            :       {</a>
<a name="406"><span class="lineNum">     406 </span>            :         printError(std::string(&quot;Invalid expected matrix dimensions for parameter &quot;) + resolved(name_prefixed) + std::string(&quot; (rows and cols must be &gt;= 0)&quot;));</a>
<a name="407"><span class="lineNum">     407 </span>            :         m_load_successful = false;</a>
<a name="408"><span class="lineNum">     408 </span>            :         return default_value;</a>
<a name="409"><span class="lineNum">     409 </span>            :       }</a>
<a name="410"><span class="lineNum">     410 </span>            :       total_cols += col;</a>
<a name="411"><span class="lineNum">     411 </span>            :     }</a>
<a name="412"><span class="lineNum">     412 </span>            :     </a>
<a name="413"><span class="lineNum">     413 </span>            :     //}</a>
<a name="414"><span class="lineNum">     414 </span>            : </a>
<a name="415"><span class="lineNum">     415 </span>            :     const auto [loaded_matrix, loaded_ok] = loadMatrixX(name + &quot;/data&quot;, MatrixX&lt;T&gt;(), rows, total_cols, optional, unique, NO_SWAP, false);</a>
<a name="416"><span class="lineNum">     416 </span>            :     /* std::cout &lt;&lt; &quot;loaded_matrix: &quot; &lt;&lt; loaded_matrix &lt;&lt; std::endl; */</a>
<a name="417"><span class="lineNum">     417 </span>            :     /* std::cout &lt;&lt; &quot;loaded_matrix: &quot; &lt;&lt; loaded_matrix.rows() &lt;&lt; &quot;x&quot; &lt;&lt; loaded_matrix.cols() &lt;&lt; std::endl; */</a>
<a name="418"><span class="lineNum">     418 </span>            :     /* std::cout &lt;&lt; &quot;expected dims: &quot; &lt;&lt; rows &lt;&lt; &quot;x&quot; &lt;&lt; total_cols &lt;&lt; std::endl; */</a>
<a name="419"><span class="lineNum">     419 </span>            :     if (loaded_matrix.rows() != rows || loaded_matrix.cols() != total_cols)</a>
<a name="420"><span class="lineNum">     420 </span>            :     {</a>
<a name="421"><span class="lineNum">     421 </span>            :       m_load_successful = false;</a>
<a name="422"><span class="lineNum">     422 </span>            :       return default_value;</a>
<a name="423"><span class="lineNum">     423 </span>            :     }</a>
<a name="424"><span class="lineNum">     424 </span>            : </a>
<a name="425"><span class="lineNum">     425 </span>            :     int cols_loaded = 0;</a>
<a name="426"><span class="lineNum">     426 </span>            :     for (unsigned it = 0; it &lt; cols.size(); it++)</a>
<a name="427"><span class="lineNum">     427 </span>            :     {</a>
<a name="428"><span class="lineNum">     428 </span>            :       const int cur_cols = cols.at(it);</a>
<a name="429"><span class="lineNum">     429 </span>            :       const MatrixX&lt;T&gt; cur_mat = loaded_matrix.block(0, cols_loaded, rows, cur_cols);</a>
<a name="430"><span class="lineNum">     430 </span>            :       /* std::cout &lt;&lt; &quot;cur_mat: &quot; &lt;&lt; cur_mat &lt;&lt; std::endl; */</a>
<a name="431"><span class="lineNum">     431 </span>            :       loaded.push_back(cur_mat);</a>
<a name="432"><span class="lineNum">     432 </span>            :       cols_loaded += cur_cols;</a>
<a name="433"><span class="lineNum">     433 </span>            :       printValue(name_prefixed + &quot;/matrix#&quot; + std::to_string(it), cur_mat);</a>
<a name="434"><span class="lineNum">     434 </span>            :     }</a>
<a name="435"><span class="lineNum">     435 </span>            :     return loaded;</a>
<a name="436"><span class="lineNum">     436 </span>            :   }</a>
<a name="437"><span class="lineNum">     437 </span>            :   //}</a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span>            :   /* load helper function for generic types //{ */</a>
<a name="440"><span class="lineNum">     440 </span>            :   // This function tries to load a parameter with name 'name' and a default value.</a>
<a name="441"><span class="lineNum">     441 </span>            :   // You can use the flag 'optional' to not throw a ROS_ERROR when the parameter</a>
<a name="442"><span class="lineNum">     442 </span>            :   // cannot be loaded and the flag 'printValues' to set whether the loaded</a>
<a name="443"><span class="lineNum">     443 </span>            :   // value and name of the parameter should be printed to cout.</a>
<a name="444"><span class="lineNum">     444 </span>            :   // If 'optional' is set to false and the parameter could not be loaded,</a>
<a name="445"><span class="lineNum">     445 </span>            :   // the flag 'load_successful' is set to false and a ROS_ERROR message</a>
<a name="446"><span class="lineNum">     446 </span>            :   // is printer.</a>
<a name="447"><span class="lineNum">     447 </span>            :   // If 'unique' flag is set to false then the parameter is not checked</a>
<a name="448"><span class="lineNum">     448 </span>            :   // for being loaded twice.</a>
<a name="449"><span class="lineNum">     449 </span>            :   // Returns a tuple, containing either the loaded or the default value and a bool,</a>
<a name="450"><span class="lineNum">     450 </span>            :   // indicating if the value was loaded (true) or the default value was used (false).</a>
<a name="451"><span class="lineNum">     451 </span>            :   template &lt;typename T&gt;</a>
<a name="452"><span class="lineNum">     452 </span><span class="lineCov">      40776 :   std::pair&lt;T, bool&gt; load(const std::string&amp; name, const T&amp; default_value, optional_t optional = OPTIONAL, unique_t unique = UNIQUE)</span></a>
<a name="453"><span class="lineNum">     453 </span>            :   {</a>
<a name="454"><span class="lineNum">     454 </span><span class="lineCov">      81552 :     const std::string name_prefixed = m_prefix + name;</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineCov">      51067 :     T loaded = default_value;</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineCov">      40776 :     if (unique &amp;&amp; check_duplicit_loading(name_prefixed))</span></a>
<a name="457"><span class="lineNum">     457 </span><span class="lineNoCov">          0 :       return {loaded, false};</span></a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span><span class="lineCov">      40776 :     bool cur_load_successful = true;</span></a>
<a name="460"><span class="lineNum">     460 </span>            :     // try to load the parameter</a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">      40776 :     const bool success = m_pp.getParam(name_prefixed, loaded);</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineCov">      40776 :     if (!success)</span></a>
<a name="463"><span class="lineNum">     463 </span>            :     {</a>
<a name="464"><span class="lineNum">     464 </span>            :       // if it was not loaded, set the default value</a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">        962 :       loaded = default_value;</span></a>
<a name="466"><span class="lineNum">     466 </span><span class="lineCov">        962 :       if (!optional)</span></a>
<a name="467"><span class="lineNum">     467 </span>            :       {</a>
<a name="468"><span class="lineNum">     468 </span>            :         // if the parameter was compulsory, alert the user and set the flag</a>
<a name="469"><span class="lineNum">     469 </span><span class="lineNoCov">          0 :         printError(std::string(&quot;Could not load non-optional parameter &quot;) + resolved(name_prefixed));</span></a>
<a name="470"><span class="lineNum">     470 </span><span class="lineNoCov">          0 :         cur_load_successful = false;</span></a>
<a name="471"><span class="lineNum">     471 </span>            :       }</a>
<a name="472"><span class="lineNum">     472 </span>            :     }</a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">      40776 :     if (cur_load_successful)</span></a>
<a name="475"><span class="lineNum">     475 </span>            :     {</a>
<a name="476"><span class="lineNum">     476 </span>            :       // everything is fine and just print the name_prefixed and value if required</a>
<a name="477"><span class="lineNum">     477 </span><span class="lineCov">      40776 :       if (m_print_values)</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">      40776 :         printValue(name_prefixed, loaded);</span></a>
<a name="479"><span class="lineNum">     479 </span>            :       // mark the param name_prefixed as successfully loaded</a>
<a name="480"><span class="lineNum">     480 </span><span class="lineCov">      40776 :       m_loaded_params.insert(name_prefixed);</span></a>
<a name="481"><span class="lineNum">     481 </span>            :     } else</a>
<a name="482"><span class="lineNum">     482 </span>            :     {</a>
<a name="483"><span class="lineNum">     483 </span><span class="lineNoCov">          0 :       m_load_successful = false;</span></a>
<a name="484"><span class="lineNum">     484 </span>            :     }</a>
<a name="485"><span class="lineNum">     485 </span>            :     // finally, return the resulting value</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineCov">      40776 :     return {loaded, success};</span></a>
<a name="487"><span class="lineNum">     487 </span>            :   }</a>
<a name="488"><span class="lineNum">     488 </span>            :   //}</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span>            : public:</a>
<a name="491"><span class="lineNum">     491 </span>            :   /*!</a>
<a name="492"><span class="lineNum">     492 </span>            :     * \brief Main constructor.</a>
<a name="493"><span class="lineNum">     493 </span>            :     *</a>
<a name="494"><span class="lineNum">     494 </span>            :     * \param nh            The parameters will be loaded from rosparam using this node handle.</a>
<a name="495"><span class="lineNum">     495 </span>            :     * \param printValues  If true, the loaded values will be printed to stdout using std::cout or ROS_INFO if node_name is not empty.</a>
<a name="496"><span class="lineNum">     496 </span>            :     * \param node_name     Optional node name used when printing the loaded values or loading errors.</a>
<a name="497"><span class="lineNum">     497 </span>            :     */</a>
<a name="498"><span class="lineNum">     498 </span><span class="lineCov">       1857 :   ParamLoader(const ros::NodeHandle&amp; nh, bool printValues = true, std::string_view node_name = std::string())</span></a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">       1857 :       : m_load_successful(true),</span></a>
<a name="500"><span class="lineNum">     500 </span>            :         m_print_values(printValues),</a>
<a name="501"><span class="lineNum">     501 </span>            :         m_node_name(node_name),</a>
<a name="502"><span class="lineNum">     502 </span>            :         m_nh(nh),</a>
<a name="503"><span class="lineNum">     503 </span><span class="lineCov">       1857 :         m_pp(nh, m_node_name)</span></a>
<a name="504"><span class="lineNum">     504 </span>            :   {</a>
<a name="505"><span class="lineNum">     505 </span>            :     /* std::cout &lt;&lt; &quot;Initialized1 ParamLoader for node &quot; &lt;&lt; node_name &lt;&lt; std::endl; */</a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">       1857 :   }</span></a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :   /* Constructor overloads //{ */</a>
<a name="509"><span class="lineNum">     509 </span>            :   /*!</a>
<a name="510"><span class="lineNum">     510 </span>            :     * \brief Convenience overload to enable writing ParamLoader pl(nh, node_name);</a>
<a name="511"><span class="lineNum">     511 </span>            :     *</a>
<a name="512"><span class="lineNum">     512 </span>            :     * \param nh            The parameters will be loaded from rosparam using this node handle.</a>
<a name="513"><span class="lineNum">     513 </span>            :     * \param node_name     Optional node name used when printing the loaded values or loading errors.</a>
<a name="514"><span class="lineNum">     514 </span>            :     */</a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">        805 :   ParamLoader(const ros::NodeHandle&amp; nh, std::string_view node_name)</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">        805 :       : ParamLoader(nh, true, node_name)</span></a>
<a name="517"><span class="lineNum">     517 </span>            :   {</a>
<a name="518"><span class="lineNum">     518 </span>            :     /* std::cout &lt;&lt; &quot;Initialized2 ParamLoader for node &quot; &lt;&lt; node_name &lt;&lt; std::endl; */</a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">        805 :   }</span></a>
<a name="520"><span class="lineNum">     520 </span>            : </a>
<a name="521"><span class="lineNum">     521 </span>            :   /*!</a>
<a name="522"><span class="lineNum">     522 </span>            :     * \brief Convenience overload to enable writing ParamLoader pl(nh, &quot;node_name&quot;);</a>
<a name="523"><span class="lineNum">     523 </span>            :     *</a>
<a name="524"><span class="lineNum">     524 </span>            :     * \param nh            The parameters will be loaded from rosparam using this node handle.</a>
<a name="525"><span class="lineNum">     525 </span>            :     * \param node_name     Optional node name used when printing the loaded values or loading errors.</a>
<a name="526"><span class="lineNum">     526 </span>            :     */</a>
<a name="527"><span class="lineNum">     527 </span>            :   ParamLoader(const std::string&amp; filepath, const ros::NodeHandle&amp; nh)</a>
<a name="528"><span class="lineNum">     528 </span>            :     : ParamLoader(nh, &quot;none&quot;)</a>
<a name="529"><span class="lineNum">     529 </span>            :   {</a>
<a name="530"><span class="lineNum">     530 </span>            :     YAML::Node node = YAML::Load(filepath);</a>
<a name="531"><span class="lineNum">     531 </span>            :   }</a>
<a name="532"><span class="lineNum">     532 </span>            :   //}</a>
<a name="533"><span class="lineNum">     533 </span>            : </a>
<a name="534"><span class="lineNum">     534 </span>            :   /* setPrefix function //{ */</a>
<a name="535"><span class="lineNum">     535 </span>            :   </a>
<a name="536"><span class="lineNum">     536 </span>            :   /*!</a>
<a name="537"><span class="lineNum">     537 </span>            :     * \brief All loaded parameters will be prefixed with this string.</a>
<a name="538"><span class="lineNum">     538 </span>            :     *</a>
<a name="539"><span class="lineNum">     539 </span>            :     * \param prefix  the prefix to be applied to all loaded parameters from now on.</a>
<a name="540"><span class="lineNum">     540 </span>            :     */</a>
<a name="541"><span class="lineNum">     541 </span><span class="lineCov">        993 :   void setPrefix(const std::string&amp; prefix)</span></a>
<a name="542"><span class="lineNum">     542 </span>            :   {</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">        993 :     m_prefix = prefix;</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">        993 :   }</span></a>
<a name="545"><span class="lineNum">     545 </span>            :   </a>
<a name="546"><span class="lineNum">     546 </span>            :   //}</a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span>            :   /* getPrefix function //{ */</a>
<a name="549"><span class="lineNum">     549 </span>            :   </a>
<a name="550"><span class="lineNum">     550 </span>            :   /*!</a>
<a name="551"><span class="lineNum">     551 </span>            :     * \brief Returns the current parameter name prefix.</a>
<a name="552"><span class="lineNum">     552 </span>            :     *</a>
<a name="553"><span class="lineNum">     553 </span>            :     * \return the current prefix to be applied to the loaded parameters.</a>
<a name="554"><span class="lineNum">     554 </span>            :     */</a>
<a name="555"><span class="lineNum">     555 </span>            :   std::string getPrefix()</a>
<a name="556"><span class="lineNum">     556 </span>            :   {</a>
<a name="557"><span class="lineNum">     557 </span>            :     return m_prefix;</a>
<a name="558"><span class="lineNum">     558 </span>            :   }</a>
<a name="559"><span class="lineNum">     559 </span>            :   </a>
<a name="560"><span class="lineNum">     560 </span>            :   //}</a>
<a name="561"><span class="lineNum">     561 </span>            : </a>
<a name="562"><span class="lineNum">     562 </span>            :   /* addYamlFile() function //{ */</a>
<a name="563"><span class="lineNum">     563 </span>            :   </a>
<a name="564"><span class="lineNum">     564 </span>            :   /*!</a>
<a name="565"><span class="lineNum">     565 </span>            :     * \brief Adds the specified file as a source of static parameters.</a>
<a name="566"><span class="lineNum">     566 </span>            :     *</a>
<a name="567"><span class="lineNum">     567 </span>            :     * \param filepath The full path to the yaml file to be loaded.</a>
<a name="568"><span class="lineNum">     568 </span>            :     * \return true if loading and parsing the file was successful, false otherwise.</a>
<a name="569"><span class="lineNum">     569 </span>            :     */</a>
<a name="570"><span class="lineNum">     570 </span><span class="lineCov">       5338 :   bool addYamlFile(const std::string&amp; filepath)</span></a>
<a name="571"><span class="lineNum">     571 </span>            :   {</a>
<a name="572"><span class="lineNum">     572 </span><span class="lineCov">       5338 :     return m_pp.addYamlFile(filepath);</span></a>
<a name="573"><span class="lineNum">     573 </span>            :   }</a>
<a name="574"><span class="lineNum">     574 </span>            :   //}</a>
<a name="575"><span class="lineNum">     575 </span>            : </a>
<a name="576"><span class="lineNum">     576 </span>            :   /* addYamlFileFromParam() function //{ */</a>
<a name="577"><span class="lineNum">     577 </span>            :   </a>
<a name="578"><span class="lineNum">     578 </span>            :   /*!</a>
<a name="579"><span class="lineNum">     579 </span>            :     * \brief Loads a filepath from a parameter loads that file as a YAML.</a>
<a name="580"><span class="lineNum">     580 </span>            :     *</a>
<a name="581"><span class="lineNum">     581 </span>            :     * \param param_name Name of the parameter from which to load the YAML filename to be loaded.</a>
<a name="582"><span class="lineNum">     582 </span>            :     * \return true      if loading and parsing the file was successful, false otherwise.</a>
<a name="583"><span class="lineNum">     583 </span>            :     */</a>
<a name="584"><span class="lineNum">     584 </span><span class="lineCov">       1264 :   bool addYamlFileFromParam(const std::string&amp; param_name)</span></a>
<a name="585"><span class="lineNum">     585 </span>            :   {</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineCov">       2528 :     std::string filepath;</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">       1264 :     if (!loadParam(param_name, filepath))</span></a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :       return false;</span></a>
<a name="589"><span class="lineNum">     589 </span><span class="lineCov">       1264 :     return m_pp.addYamlFile(filepath);</span></a>
<a name="590"><span class="lineNum">     590 </span>            :   }</a>
<a name="591"><span class="lineNum">     591 </span>            :   //}</a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            :   /* loadedSuccessfully function //{ */</a>
<a name="594"><span class="lineNum">     594 </span>            :   /*!</a>
<a name="595"><span class="lineNum">     595 </span>            :     * \brief Indicates whether all compulsory parameters were successfully loaded.</a>
<a name="596"><span class="lineNum">     596 </span>            :     *</a>
<a name="597"><span class="lineNum">     597 </span>            :     * \return false if any compulsory parameter was not loaded (is not present at rosparam server). Otherwise returns true.</a>
<a name="598"><span class="lineNum">     598 </span>            :     */</a>
<a name="599"><span class="lineNum">     599 </span><span class="lineCov">       2089 :   bool loadedSuccessfully()</span></a>
<a name="600"><span class="lineNum">     600 </span>            :   {</a>
<a name="601"><span class="lineNum">     601 </span><span class="lineCov">       2089 :     return m_load_successful;</span></a>
<a name="602"><span class="lineNum">     602 </span>            :   }</a>
<a name="603"><span class="lineNum">     603 </span>            :   //}</a>
<a name="604"><span class="lineNum">     604 </span>            : </a>
<a name="605"><span class="lineNum">     605 </span>            :   /* resetLoadedSuccessfully function //{ */</a>
<a name="606"><span class="lineNum">     606 </span>            :   /*!</a>
<a name="607"><span class="lineNum">     607 </span>            :     * \brief Resets the loadedSuccessfully flag back to true.</a>
<a name="608"><span class="lineNum">     608 </span>            :     */</a>
<a name="609"><span class="lineNum">     609 </span>            :   void resetLoadedSuccessfully()</a>
<a name="610"><span class="lineNum">     610 </span>            :   {</a>
<a name="611"><span class="lineNum">     611 </span>            :     m_load_successful = true;</a>
<a name="612"><span class="lineNum">     612 </span>            :   }</a>
<a name="613"><span class="lineNum">     613 </span>            :   //}</a>
<a name="614"><span class="lineNum">     614 </span>            : </a>
<a name="615"><span class="lineNum">     615 </span>            :   /* resetUniques function //{ */</a>
<a name="616"><span class="lineNum">     616 </span>            :   /*!</a>
<a name="617"><span class="lineNum">     617 </span>            :     * \brief Resets the list of already loaded parameter names used when checking for uniqueness.</a>
<a name="618"><span class="lineNum">     618 </span>            :     */</a>
<a name="619"><span class="lineNum">     619 </span>            :   void resetUniques()</a>
<a name="620"><span class="lineNum">     620 </span>            :   {</a>
<a name="621"><span class="lineNum">     621 </span>            :     m_loaded_params.clear();</a>
<a name="622"><span class="lineNum">     622 </span>            :   }</a>
<a name="623"><span class="lineNum">     623 </span>            :   //}</a>
<a name="624"><span class="lineNum">     624 </span>            : </a>
<a name="625"><span class="lineNum">     625 </span>            :   /* loadParam function for optional parameters //{ */</a>
<a name="626"><span class="lineNum">     626 </span>            :   /*!</a>
<a name="627"><span class="lineNum">     627 </span>            :     * \brief Loads a parameter from the rosparam server with a default value.</a>
<a name="628"><span class="lineNum">     628 </span>            :     *</a>
<a name="629"><span class="lineNum">     629 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="630"><span class="lineNum">     630 </span>            :     * the default value is used.</a>
<a name="631"><span class="lineNum">     631 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="632"><span class="lineNum">     632 </span>            :     *</a>
<a name="633"><span class="lineNum">     633 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="634"><span class="lineNum">     634 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="635"><span class="lineNum">     635 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="636"><span class="lineNum">     636 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="637"><span class="lineNum">     637 </span>            :     */</a>
<a name="638"><span class="lineNum">     638 </span>            :   template &lt;typename T&gt;</a>
<a name="639"><span class="lineNum">     639 </span><span class="lineCov">       3406 :   bool loadParam(const std::string&amp; name, T&amp; out_value, const T&amp; default_value)</span></a>
<a name="640"><span class="lineNum">     640 </span>            :   {</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineCov">       3406 :     const auto [ret, success] = load&lt;T&gt;(name, default_value, OPTIONAL, UNIQUE);</span></a>
<a name="642"><span class="lineNum">     642 </span><span class="lineCov">       3406 :     out_value = ret;</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineCov">       3406 :     return success;</span></a>
<a name="644"><span class="lineNum">     644 </span>            :   }</a>
<a name="645"><span class="lineNum">     645 </span>            :   /*!</a>
<a name="646"><span class="lineNum">     646 </span>            :     * \brief Loads a parameter from the rosparam server with a default value.</a>
<a name="647"><span class="lineNum">     647 </span>            :     *</a>
<a name="648"><span class="lineNum">     648 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="649"><span class="lineNum">     649 </span>            :     * the default value is used.</a>
<a name="650"><span class="lineNum">     650 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="651"><span class="lineNum">     651 </span>            :     *</a>
<a name="652"><span class="lineNum">     652 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="653"><span class="lineNum">     653 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="654"><span class="lineNum">     654 </span>            :     * \return              The loaded parameter value.</a>
<a name="655"><span class="lineNum">     655 </span>            :     */</a>
<a name="656"><span class="lineNum">     656 </span>            :   template &lt;typename T&gt;</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">        235 :   T loadParam2(const std::string&amp; name, const T&amp; default_value)</span></a>
<a name="658"><span class="lineNum">     658 </span>            :   {</a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">        470 :     const auto loaded = load&lt;T&gt;(name, default_value, OPTIONAL, UNIQUE);</span></a>
<a name="660"><span class="lineNum">     660 </span><span class="lineCov">        470 :     return loaded.first;</span></a>
<a name="661"><span class="lineNum">     661 </span>            :   }</a>
<a name="662"><span class="lineNum">     662 </span>            :   /*!</a>
<a name="663"><span class="lineNum">     663 </span>            :     * \brief Loads a parameter from the rosparam server with a default value.</a>
<a name="664"><span class="lineNum">     664 </span>            :     *</a>
<a name="665"><span class="lineNum">     665 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="666"><span class="lineNum">     666 </span>            :     * the default value is used.</a>
<a name="667"><span class="lineNum">     667 </span>            :     * Using this method, the parameter can be loaded multiple times using the same ParamLoader instance without error.</a>
<a name="668"><span class="lineNum">     668 </span>            :     *</a>
<a name="669"><span class="lineNum">     669 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="670"><span class="lineNum">     670 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="671"><span class="lineNum">     671 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="672"><span class="lineNum">     672 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="673"><span class="lineNum">     673 </span>            :     */</a>
<a name="674"><span class="lineNum">     674 </span>            :   template &lt;typename T&gt;</a>
<a name="675"><span class="lineNum">     675 </span>            :   bool loadParamReusable(const std::string&amp; name, T&amp; out_value, const T&amp; default_value)</a>
<a name="676"><span class="lineNum">     676 </span>            :   {</a>
<a name="677"><span class="lineNum">     677 </span>            :     const auto [ret, success] = load&lt;T&gt;(name, default_value, OPTIONAL, REUSABLE);</a>
<a name="678"><span class="lineNum">     678 </span>            :     out_value = ret;</a>
<a name="679"><span class="lineNum">     679 </span>            :     return success;</a>
<a name="680"><span class="lineNum">     680 </span>            :   }</a>
<a name="681"><span class="lineNum">     681 </span>            :   /*!</a>
<a name="682"><span class="lineNum">     682 </span>            :     * \brief Loads an optional reusable parameter from the rosparam server.</a>
<a name="683"><span class="lineNum">     683 </span>            :     *</a>
<a name="684"><span class="lineNum">     684 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="685"><span class="lineNum">     685 </span>            :     * the default value is used.</a>
<a name="686"><span class="lineNum">     686 </span>            :     * Using this method, the parameter can be loaded multiple times using the same ParamLoader instance without error.</a>
<a name="687"><span class="lineNum">     687 </span>            :     *</a>
<a name="688"><span class="lineNum">     688 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="689"><span class="lineNum">     689 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="690"><span class="lineNum">     690 </span>            :     * \return              The loaded parameter value.</a>
<a name="691"><span class="lineNum">     691 </span>            :     */</a>
<a name="692"><span class="lineNum">     692 </span>            :   template &lt;typename T&gt;</a>
<a name="693"><span class="lineNum">     693 </span>            :   T loadParamReusable2(const std::string&amp; name, const T&amp; default_value)</a>
<a name="694"><span class="lineNum">     694 </span>            :   {</a>
<a name="695"><span class="lineNum">     695 </span>            :     const auto [ret, success] = load&lt;T&gt;(name, default_value, OPTIONAL, REUSABLE);</a>
<a name="696"><span class="lineNum">     696 </span>            :     return ret;</a>
<a name="697"><span class="lineNum">     697 </span>            :   }</a>
<a name="698"><span class="lineNum">     698 </span>            :   //}</a>
<a name="699"><span class="lineNum">     699 </span>            : </a>
<a name="700"><span class="lineNum">     700 </span>            :   /* loadParam function for compulsory parameters //{ */</a>
<a name="701"><span class="lineNum">     701 </span>            :   /*!</a>
<a name="702"><span class="lineNum">     702 </span>            :     * \brief Loads a compulsory parameter from the rosparam server.</a>
<a name="703"><span class="lineNum">     703 </span>            :     *</a>
<a name="704"><span class="lineNum">     704 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="705"><span class="lineNum">     705 </span>            :     * the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="706"><span class="lineNum">     706 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="707"><span class="lineNum">     707 </span>            :     *</a>
<a name="708"><span class="lineNum">     708 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="709"><span class="lineNum">     709 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="710"><span class="lineNum">     710 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="711"><span class="lineNum">     711 </span>            :     */</a>
<a name="712"><span class="lineNum">     712 </span>            :   template &lt;typename T&gt;</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">      37135 :   bool loadParam(const std::string&amp; name, T&amp; out_value)</span></a>
<a name="714"><span class="lineNum">     714 </span>            :   {</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">      47191 :     const auto [ret, success] = load&lt;T&gt;(name, T(), COMPULSORY, UNIQUE);</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineCov">      37135 :     out_value = ret;</span></a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">      47191 :     return success;</span></a>
<a name="718"><span class="lineNum">     718 </span>            :   }</a>
<a name="719"><span class="lineNum">     719 </span>            :   /*!</a>
<a name="720"><span class="lineNum">     720 </span>            :     * \brief Loads a compulsory parameter from the rosparam server.</a>
<a name="721"><span class="lineNum">     721 </span>            :     *</a>
<a name="722"><span class="lineNum">     722 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="723"><span class="lineNum">     723 </span>            :     * the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="724"><span class="lineNum">     724 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="725"><span class="lineNum">     725 </span>            :     *</a>
<a name="726"><span class="lineNum">     726 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="727"><span class="lineNum">     727 </span>            :     * \return              The loaded parameter value.</a>
<a name="728"><span class="lineNum">     728 </span>            :     */</a>
<a name="729"><span class="lineNum">     729 </span>            :   template &lt;typename T&gt;</a>
<a name="730"><span class="lineNum">     730 </span>            :   T loadParam2(const std::string&amp; name)</a>
<a name="731"><span class="lineNum">     731 </span>            :   {</a>
<a name="732"><span class="lineNum">     732 </span>            :     const auto [ret, success] = load&lt;T&gt;(name, T(), COMPULSORY, UNIQUE);</a>
<a name="733"><span class="lineNum">     733 </span>            :     return ret;</a>
<a name="734"><span class="lineNum">     734 </span>            :   }</a>
<a name="735"><span class="lineNum">     735 </span>            :   /*!</a>
<a name="736"><span class="lineNum">     736 </span>            :     * \brief Loads a compulsory parameter from the rosparam server.</a>
<a name="737"><span class="lineNum">     737 </span>            :     *</a>
<a name="738"><span class="lineNum">     738 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="739"><span class="lineNum">     739 </span>            :     * the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="740"><span class="lineNum">     740 </span>            :     * Using this method, the parameter can be loaded multiple times using the same ParamLoader instance without error.</a>
<a name="741"><span class="lineNum">     741 </span>            :     *</a>
<a name="742"><span class="lineNum">     742 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="743"><span class="lineNum">     743 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="744"><span class="lineNum">     744 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="745"><span class="lineNum">     745 </span>            :     */</a>
<a name="746"><span class="lineNum">     746 </span>            :   template &lt;typename T&gt;</a>
<a name="747"><span class="lineNum">     747 </span>            :   bool loadParamReusable(const std::string&amp; name, T&amp; out_value)</a>
<a name="748"><span class="lineNum">     748 </span>            :   {</a>
<a name="749"><span class="lineNum">     749 </span>            :     const auto [ret, success] = load&lt;T&gt;(name, T(), COMPULSORY, REUSABLE);</a>
<a name="750"><span class="lineNum">     750 </span>            :     out_value = ret;</a>
<a name="751"><span class="lineNum">     751 </span>            :     return success;</a>
<a name="752"><span class="lineNum">     752 </span>            :   }</a>
<a name="753"><span class="lineNum">     753 </span>            :   /*!</a>
<a name="754"><span class="lineNum">     754 </span>            :     * \brief Loads a compulsory parameter from the rosparam server.</a>
<a name="755"><span class="lineNum">     755 </span>            :     *</a>
<a name="756"><span class="lineNum">     756 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="757"><span class="lineNum">     757 </span>            :     * the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="758"><span class="lineNum">     758 </span>            :     * Using this method, the parameter can be loaded multiple times using the same ParamLoader instance without error.</a>
<a name="759"><span class="lineNum">     759 </span>            :     *</a>
<a name="760"><span class="lineNum">     760 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="761"><span class="lineNum">     761 </span>            :     * \return              The loaded parameter value.</a>
<a name="762"><span class="lineNum">     762 </span>            :     */</a>
<a name="763"><span class="lineNum">     763 </span>            :   template &lt;typename T&gt;</a>
<a name="764"><span class="lineNum">     764 </span>            :   T loadParamReusable2(const std::string&amp; name)</a>
<a name="765"><span class="lineNum">     765 </span>            :   {</a>
<a name="766"><span class="lineNum">     766 </span>            :     const auto [ret, success] = load&lt;T&gt;(name, T(), COMPULSORY, REUSABLE);</a>
<a name="767"><span class="lineNum">     767 </span>            :     return ret;</a>
<a name="768"><span class="lineNum">     768 </span>            :   }</a>
<a name="769"><span class="lineNum">     769 </span>            :   //}</a>
<a name="770"><span class="lineNum">     770 </span>            : </a>
<a name="771"><span class="lineNum">     771 </span>            :   /* loadParam specializations for ros::Duration type //{ */</a>
<a name="772"><span class="lineNum">     772 </span>            : </a>
<a name="773"><span class="lineNum">     773 </span>            :   /*!</a>
<a name="774"><span class="lineNum">     774 </span>            :     * \brief An overload for loading ros::Duration.</a>
<a name="775"><span class="lineNum">     775 </span>            :     *</a>
<a name="776"><span class="lineNum">     776 </span>            :     * The duration will be loaded as a \p double, representing a number of seconds, and then converted to ros::Duration.</a>
<a name="777"><span class="lineNum">     777 </span>            :     *</a>
<a name="778"><span class="lineNum">     778 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="779"><span class="lineNum">     779 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="780"><span class="lineNum">     780 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="781"><span class="lineNum">     781 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="782"><span class="lineNum">     782 </span>            :     */</a>
<a name="783"><span class="lineNum">     783 </span>            :   bool loadParam(const std::string&amp; name, ros::Duration&amp; out, const ros::Duration&amp; default_value)</a>
<a name="784"><span class="lineNum">     784 </span>            :   {</a>
<a name="785"><span class="lineNum">     785 </span>            :     double secs;</a>
<a name="786"><span class="lineNum">     786 </span>            :     const bool ret = loadParam&lt;double&gt;(name, secs, default_value.toSec());</a>
<a name="787"><span class="lineNum">     787 </span>            :     out = ros::Duration(secs);</a>
<a name="788"><span class="lineNum">     788 </span>            :     return ret;</a>
<a name="789"><span class="lineNum">     789 </span>            :   }</a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span>            :   /*!</a>
<a name="792"><span class="lineNum">     792 </span>            :     * \brief An overload for loading ros::Duration.</a>
<a name="793"><span class="lineNum">     793 </span>            :     *</a>
<a name="794"><span class="lineNum">     794 </span>            :     * The duration will be loaded as a \p double, representing a number of seconds, and then converted to ros::Duration.</a>
<a name="795"><span class="lineNum">     795 </span>            :     *</a>
<a name="796"><span class="lineNum">     796 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="797"><span class="lineNum">     797 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="798"><span class="lineNum">     798 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="799"><span class="lineNum">     799 </span>            :     */</a>
<a name="800"><span class="lineNum">     800 </span>            :   bool loadParam(const std::string&amp; name, ros::Duration&amp; out)</a>
<a name="801"><span class="lineNum">     801 </span>            :   {</a>
<a name="802"><span class="lineNum">     802 </span>            :     double secs;</a>
<a name="803"><span class="lineNum">     803 </span>            :     const bool ret = loadParam&lt;double&gt;(name, secs);</a>
<a name="804"><span class="lineNum">     804 </span>            :     out = ros::Duration(secs);</a>
<a name="805"><span class="lineNum">     805 </span>            :     return ret;</a>
<a name="806"><span class="lineNum">     806 </span>            :   }</a>
<a name="807"><span class="lineNum">     807 </span>            :   </a>
<a name="808"><span class="lineNum">     808 </span>            :   //}</a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span>            :   /* loadParam specializations for std_msgs::ColorRGBA type //{ */</a>
<a name="811"><span class="lineNum">     811 </span>            : </a>
<a name="812"><span class="lineNum">     812 </span>            :   /*!</a>
<a name="813"><span class="lineNum">     813 </span>            :     * \brief An overload for loading std_msgs::ColorRGBA.</a>
<a name="814"><span class="lineNum">     814 </span>            :     *</a>
<a name="815"><span class="lineNum">     815 </span>            :     * The color will be loaded as several \p double -typed variables, representing the R, G, B and A color elements.</a>
<a name="816"><span class="lineNum">     816 </span>            :     *</a>
<a name="817"><span class="lineNum">     817 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="818"><span class="lineNum">     818 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="819"><span class="lineNum">     819 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="820"><span class="lineNum">     820 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="821"><span class="lineNum">     821 </span>            :     */</a>
<a name="822"><span class="lineNum">     822 </span>            :   bool loadParam(const std::string&amp; name, std_msgs::ColorRGBA&amp; out, const std_msgs::ColorRGBA&amp; default_value = {})</a>
<a name="823"><span class="lineNum">     823 </span>            :   {</a>
<a name="824"><span class="lineNum">     824 </span>            :     std_msgs::ColorRGBA res;</a>
<a name="825"><span class="lineNum">     825 </span>            :     bool ret = true;</a>
<a name="826"><span class="lineNum">     826 </span>            :     ret = ret &amp; loadParam(name+&quot;/r&quot;, res.r, default_value.r);</a>
<a name="827"><span class="lineNum">     827 </span>            :     ret = ret &amp; loadParam(name+&quot;/g&quot;, res.g, default_value.g);</a>
<a name="828"><span class="lineNum">     828 </span>            :     ret = ret &amp; loadParam(name+&quot;/b&quot;, res.b, default_value.b);</a>
<a name="829"><span class="lineNum">     829 </span>            :     ret = ret &amp; loadParam(name+&quot;/a&quot;, res.a, default_value.a);</a>
<a name="830"><span class="lineNum">     830 </span>            :     if (ret)</a>
<a name="831"><span class="lineNum">     831 </span>            :       out = res;</a>
<a name="832"><span class="lineNum">     832 </span>            :     return ret;</a>
<a name="833"><span class="lineNum">     833 </span>            :   }</a>
<a name="834"><span class="lineNum">     834 </span>            : </a>
<a name="835"><span class="lineNum">     835 </span>            :   /*!</a>
<a name="836"><span class="lineNum">     836 </span>            :     * \brief An overload for loading std_msgs::ColorRGBA.</a>
<a name="837"><span class="lineNum">     837 </span>            :     *</a>
<a name="838"><span class="lineNum">     838 </span>            :     * The color will be loaded as several \p double -typed variables, representing the R, G, B and A color elements.</a>
<a name="839"><span class="lineNum">     839 </span>            :     *</a>
<a name="840"><span class="lineNum">     840 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="841"><span class="lineNum">     841 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="842"><span class="lineNum">     842 </span>            :     * \return              The loaded parameter value.</a>
<a name="843"><span class="lineNum">     843 </span>            :     */</a>
<a name="844"><span class="lineNum">     844 </span>            :   std_msgs::ColorRGBA loadParam2(const std::string&amp; name, const std_msgs::ColorRGBA&amp; default_value = {})</a>
<a name="845"><span class="lineNum">     845 </span>            :   {</a>
<a name="846"><span class="lineNum">     846 </span>            :     std_msgs::ColorRGBA ret;</a>
<a name="847"><span class="lineNum">     847 </span>            :     loadParam(name, ret, default_value);</a>
<a name="848"><span class="lineNum">     848 </span>            :     return ret;</a>
<a name="849"><span class="lineNum">     849 </span>            :   }</a>
<a name="850"><span class="lineNum">     850 </span>            : </a>
<a name="851"><span class="lineNum">     851 </span>            :   //}</a>
<a name="852"><span class="lineNum">     852 </span>            : </a>
<a name="853"><span class="lineNum">     853 </span>            :   /* loadParam specializations for XmlRpc::Value type //{ */</a>
<a name="854"><span class="lineNum">     854 </span>            : </a>
<a name="855"><span class="lineNum">     855 </span>            :   /*!</a>
<a name="856"><span class="lineNum">     856 </span>            :     * \brief An overload for loading an optional XmlRpc::XmlRpcValue.</a>
<a name="857"><span class="lineNum">     857 </span>            :     *</a>
<a name="858"><span class="lineNum">     858 </span>            :     * This can be used if you want to manually parse some more complex parameter but still take advantage of ParamLoader.</a>
<a name="859"><span class="lineNum">     859 </span>            :     * \warning  XmlRpc::XmlRpcValue must be loaded from a rosparam server and not directly from a YAML file</a>
<a name="860"><span class="lineNum">     860 </span>            :     * (i.e. you cannot use it to load parameters from a file added using the addYamlFile() or addYamlFileFromParam() methods).</a>
<a name="861"><span class="lineNum">     861 </span>            :     *</a>
<a name="862"><span class="lineNum">     862 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="863"><span class="lineNum">     863 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="864"><span class="lineNum">     864 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="865"><span class="lineNum">     865 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="866"><span class="lineNum">     866 </span>            :     */</a>
<a name="867"><span class="lineNum">     867 </span>            :   bool loadParam(const std::string&amp; name, XmlRpc::XmlRpcValue&amp; out, const XmlRpc::XmlRpcValue&amp; default_value)</a>
<a name="868"><span class="lineNum">     868 </span>            :   {</a>
<a name="869"><span class="lineNum">     869 </span>            :     return loadParam&lt;XmlRpc::XmlRpcValue&gt;(name, out, default_value);</a>
<a name="870"><span class="lineNum">     870 </span>            :   }</a>
<a name="871"><span class="lineNum">     871 </span>            : </a>
<a name="872"><span class="lineNum">     872 </span>            :   /*!</a>
<a name="873"><span class="lineNum">     873 </span>            :     * \brief An overload for loading a compulsory XmlRpc::XmlRpcValue.</a>
<a name="874"><span class="lineNum">     874 </span>            :     *</a>
<a name="875"><span class="lineNum">     875 </span>            :     * This can be used if you want to manually parse some more complex parameter but still take advantage of ParamLoader.</a>
<a name="876"><span class="lineNum">     876 </span>            :     * \warning  XmlRpc::XmlRpcValue must be loaded from a rosparam server and not directly from a YAML file</a>
<a name="877"><span class="lineNum">     877 </span>            :     * (i.e. you cannot use it to load parameters from a file added using the addYamlFile() or addYamlFileFromParam() methods).</a>
<a name="878"><span class="lineNum">     878 </span>            :     *</a>
<a name="879"><span class="lineNum">     879 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="880"><span class="lineNum">     880 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="881"><span class="lineNum">     881 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="882"><span class="lineNum">     882 </span>            :     */</a>
<a name="883"><span class="lineNum">     883 </span>            :   bool loadParam(const std::string&amp; name, XmlRpc::XmlRpcValue&amp; out)</a>
<a name="884"><span class="lineNum">     884 </span>            :   {</a>
<a name="885"><span class="lineNum">     885 </span>            :     return loadParam&lt;XmlRpc::XmlRpcValue&gt;(name, out);</a>
<a name="886"><span class="lineNum">     886 </span>            :   }</a>
<a name="887"><span class="lineNum">     887 </span>            : </a>
<a name="888"><span class="lineNum">     888 </span>            :   /*!</a>
<a name="889"><span class="lineNum">     889 </span>            :     * \brief An overload for loading an optional XmlRpc::XmlRpcValue.</a>
<a name="890"><span class="lineNum">     890 </span>            :     *</a>
<a name="891"><span class="lineNum">     891 </span>            :     * This can be used if you want to manually parse some more complex parameter but still take advantage of ParamLoader.</a>
<a name="892"><span class="lineNum">     892 </span>            :     * \warning  XmlRpc::XmlRpcValue must be loaded from a rosparam server and not directly from a YAML file</a>
<a name="893"><span class="lineNum">     893 </span>            :     * (i.e. you cannot use it to load parameters from a file added using the addYamlFile() or addYamlFileFromParam() methods).</a>
<a name="894"><span class="lineNum">     894 </span>            :     *</a>
<a name="895"><span class="lineNum">     895 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="896"><span class="lineNum">     896 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="897"><span class="lineNum">     897 </span>            :     * \return              the loaded parameter.</a>
<a name="898"><span class="lineNum">     898 </span>            :     */</a>
<a name="899"><span class="lineNum">     899 </span>            :   XmlRpc::XmlRpcValue loadParam2(const std::string&amp; name, const XmlRpc::XmlRpcValue&amp; default_value)</a>
<a name="900"><span class="lineNum">     900 </span>            :   {</a>
<a name="901"><span class="lineNum">     901 </span>            :     return loadParam2&lt;XmlRpc::XmlRpcValue&gt;(name, default_value);</a>
<a name="902"><span class="lineNum">     902 </span>            :   }</a>
<a name="903"><span class="lineNum">     903 </span>            : </a>
<a name="904"><span class="lineNum">     904 </span>            :   //}</a>
<a name="905"><span class="lineNum">     905 </span>            : </a>
<a name="906"><span class="lineNum">     906 </span>            :   /* loadParam specializations and convenience functions for Eigen dynamic matrix type //{ */</a>
<a name="907"><span class="lineNum">     907 </span>            : </a>
<a name="908"><span class="lineNum">     908 </span>            :   /*!</a>
<a name="909"><span class="lineNum">     909 </span>            :     * \brief An overload for loading Eigen matrices.</a>
<a name="910"><span class="lineNum">     910 </span>            :     *</a>
<a name="911"><span class="lineNum">     911 </span>            :     * Matrix dimensions are deduced from the provided default value.</a>
<a name="912"><span class="lineNum">     912 </span>            :     * For compulsory Eigen matrices, use loadMatrixStatic(), loadMatrixKnown() or loadMatrixDynamic().</a>
<a name="913"><span class="lineNum">     913 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="914"><span class="lineNum">     914 </span>            :     * the default value is used.</a>
<a name="915"><span class="lineNum">     915 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="916"><span class="lineNum">     916 </span>            :     *</a>
<a name="917"><span class="lineNum">     917 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="918"><span class="lineNum">     918 </span>            :     * \param out_value     Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="919"><span class="lineNum">     919 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="920"><span class="lineNum">     920 </span>            :     * \return              True if loaded successfully, false otherwise.</a>
<a name="921"><span class="lineNum">     921 </span>            :     */</a>
<a name="922"><span class="lineNum">     922 </span>            :   template &lt;typename T&gt;</a>
<a name="923"><span class="lineNum">     923 </span>            :   bool loadParam(const std::string&amp; name, MatrixX&lt;T&gt;&amp; mat, const MatrixX&lt;T&gt;&amp; default_value)</a>
<a name="924"><span class="lineNum">     924 </span>            :   {</a>
<a name="925"><span class="lineNum">     925 </span>            :     const int rows = default_value.rows();</a>
<a name="926"><span class="lineNum">     926 </span>            :     const int cols = default_value.cols();</a>
<a name="927"><span class="lineNum">     927 </span>            :     const bool loaded_ok = loadMatrixDynamic(name, mat, default_value, rows, cols);</a>
<a name="928"><span class="lineNum">     928 </span>            :     return loaded_ok;</a>
<a name="929"><span class="lineNum">     929 </span>            :   }</a>
<a name="930"><span class="lineNum">     930 </span>            : </a>
<a name="931"><span class="lineNum">     931 </span>            :   /*!</a>
<a name="932"><span class="lineNum">     932 </span>            :     * \brief An overload for loading Eigen matrices.</a>
<a name="933"><span class="lineNum">     933 </span>            :     *</a>
<a name="934"><span class="lineNum">     934 </span>            :     * Matrix dimensions are deduced from the provided default value.</a>
<a name="935"><span class="lineNum">     935 </span>            :     * For compulsory Eigen matrices, use loadMatrixStatic(), loadMatrixKnown() or loadMatrixDynamic().</a>
<a name="936"><span class="lineNum">     936 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="937"><span class="lineNum">     937 </span>            :     * the default value is used.</a>
<a name="938"><span class="lineNum">     938 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="939"><span class="lineNum">     939 </span>            :     *</a>
<a name="940"><span class="lineNum">     940 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="941"><span class="lineNum">     941 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="942"><span class="lineNum">     942 </span>            :     * \return              The loaded parameter value.</a>
<a name="943"><span class="lineNum">     943 </span>            :     */</a>
<a name="944"><span class="lineNum">     944 </span>            :   template &lt;typename T&gt;</a>
<a name="945"><span class="lineNum">     945 </span>            :   MatrixX&lt;T&gt; loadParam2(const std::string&amp; name, const MatrixX&lt;T&gt;&amp; default_value)</a>
<a name="946"><span class="lineNum">     946 </span>            :   {</a>
<a name="947"><span class="lineNum">     947 </span>            :     MatrixX&lt;T&gt; ret;</a>
<a name="948"><span class="lineNum">     948 </span>            :     loadParam(name, ret, default_value);</a>
<a name="949"><span class="lineNum">     949 </span>            :     return ret;</a>
<a name="950"><span class="lineNum">     950 </span>            :   }</a>
<a name="951"><span class="lineNum">     951 </span>            :   </a>
<a name="952"><span class="lineNum">     952 </span>            :   //}</a>
<a name="953"><span class="lineNum">     953 </span>            : </a>
<a name="954"><span class="lineNum">     954 </span>            :   // loadMatrixStatic function for loading of static Eigen::Matrices //{</a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span>            :   /*!</a>
<a name="957"><span class="lineNum">     957 </span>            :     * \brief Specialized method for loading compulsory Eigen matrix parameters.</a>
<a name="958"><span class="lineNum">     958 </span>            :     *</a>
<a name="959"><span class="lineNum">     959 </span>            :     * This variant assumes that the matrix dimensions are known in compiletime.</a>
<a name="960"><span class="lineNum">     960 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="961"><span class="lineNum">     961 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="962"><span class="lineNum">     962 </span>            :     * the loading process is unsuccessful.</a>
<a name="963"><span class="lineNum">     963 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="964"><span class="lineNum">     964 </span>            :     *</a>
<a name="965"><span class="lineNum">     965 </span>            :     * \tparam rows  Expected number of rows of the matrix.</a>
<a name="966"><span class="lineNum">     966 </span>            :     * \tparam cols  Expected number of columns of the matrix.</a>
<a name="967"><span class="lineNum">     967 </span>            :     *</a>
<a name="968"><span class="lineNum">     968 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="969"><span class="lineNum">     969 </span>            :     * \param mat   Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="970"><span class="lineNum">     970 </span>            :     * \return      true if loaded successfully, false otherwise.</a>
<a name="971"><span class="lineNum">     971 </span>            :     *</a>
<a name="972"><span class="lineNum">     972 </span>            :     */</a>
<a name="973"><span class="lineNum">     973 </span>            :   template &lt;int rows, int cols, typename T&gt;</a>
<a name="974"><span class="lineNum">     974 </span>            :   bool loadMatrixStatic(const std::string&amp; name, Eigen::Matrix&lt;T, rows, cols&gt;&amp; mat)</a>
<a name="975"><span class="lineNum">     975 </span>            :   {</a>
<a name="976"><span class="lineNum">     976 </span>            :     const auto [ret, loaded_ok] = loadMatrixStatic_internal&lt;rows, cols, T&gt;(name, Eigen::Matrix&lt;T, rows, cols&gt;::Zero(), COMPULSORY, UNIQUE);</a>
<a name="977"><span class="lineNum">     977 </span>            :     mat = ret;</a>
<a name="978"><span class="lineNum">     978 </span>            :     return loaded_ok;</a>
<a name="979"><span class="lineNum">     979 </span>            :   }</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            :   /*!</a>
<a name="982"><span class="lineNum">     982 </span>            :     * \brief Specialized method for loading Eigen matrix parameters with default value.</a>
<a name="983"><span class="lineNum">     983 </span>            :     *</a>
<a name="984"><span class="lineNum">     984 </span>            :     * This variant assumes that the matrix dimensions are known in compiletime.</a>
<a name="985"><span class="lineNum">     985 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="986"><span class="lineNum">     986 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="987"><span class="lineNum">     987 </span>            :     * the default value is used.</a>
<a name="988"><span class="lineNum">     988 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="989"><span class="lineNum">     989 </span>            :     *</a>
<a name="990"><span class="lineNum">     990 </span>            :     * \tparam rows          Expected number of rows of the matrix.</a>
<a name="991"><span class="lineNum">     991 </span>            :     * \tparam cols          Expected number of columns of the matrix.</a>
<a name="992"><span class="lineNum">     992 </span>            :     *</a>
<a name="993"><span class="lineNum">     993 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="994"><span class="lineNum">     994 </span>            :     * \param mat           Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="995"><span class="lineNum">     995 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="996"><span class="lineNum">     996 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="997"><span class="lineNum">     997 </span>            :     *</a>
<a name="998"><span class="lineNum">     998 </span>            :     */</a>
<a name="999"><span class="lineNum">     999 </span>            :   template &lt;int rows, int cols, typename T, typename Derived&gt;</a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineCov">         47 :   bool loadMatrixStatic(const std::string&amp; name, Eigen::Matrix&lt;T, rows, cols&gt;&amp; mat, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value)</span></a>
<a name="1001"><span class="lineNum">    1001 </span>            :   {</a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">         47 :     const auto [ret, loaded_ok] = loadMatrixStatic_internal&lt;rows, cols, T&gt;(name, Eigen::Matrix&lt;T, rows, cols&gt;(default_value), OPTIONAL, UNIQUE);</span></a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineCov">         47 :     mat = ret;</span></a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">         47 :     return loaded_ok;</span></a>
<a name="1005"><span class="lineNum">    1005 </span>            :   }</a>
<a name="1006"><span class="lineNum">    1006 </span>            : </a>
<a name="1007"><span class="lineNum">    1007 </span>            :   /*!</a>
<a name="1008"><span class="lineNum">    1008 </span>            :     * \brief Specialized method for loading compulsory Eigen matrix parameters.</a>
<a name="1009"><span class="lineNum">    1009 </span>            :     *</a>
<a name="1010"><span class="lineNum">    1010 </span>            :     * This variant assumes that the matrix dimensions are known in compiletime.</a>
<a name="1011"><span class="lineNum">    1011 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1012"><span class="lineNum">    1012 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1013"><span class="lineNum">    1013 </span>            :     * the loading process is unsuccessful.</a>
<a name="1014"><span class="lineNum">    1014 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1015"><span class="lineNum">    1015 </span>            :     *</a>
<a name="1016"><span class="lineNum">    1016 </span>            :     * \tparam rows  Expected number of rows of the matrix.</a>
<a name="1017"><span class="lineNum">    1017 </span>            :     * \tparam cols  Expected number of columns of the matrix.</a>
<a name="1018"><span class="lineNum">    1018 </span>            :     *</a>
<a name="1019"><span class="lineNum">    1019 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1020"><span class="lineNum">    1020 </span>            :     * \return      The loaded parameter value.</a>
<a name="1021"><span class="lineNum">    1021 </span>            :     *</a>
<a name="1022"><span class="lineNum">    1022 </span>            :     */</a>
<a name="1023"><span class="lineNum">    1023 </span>            :   template &lt;int rows, int cols, typename T = double&gt;</a>
<a name="1024"><span class="lineNum">    1024 </span>            :   Eigen::Matrix&lt;T, rows, cols&gt; loadMatrixStatic2(const std::string&amp; name)</a>
<a name="1025"><span class="lineNum">    1025 </span>            :   {</a>
<a name="1026"><span class="lineNum">    1026 </span>            :     Eigen::Matrix&lt;T, rows, cols&gt; ret;</a>
<a name="1027"><span class="lineNum">    1027 </span>            :     loadMatrixStatic(name, ret);</a>
<a name="1028"><span class="lineNum">    1028 </span>            :     return ret;</a>
<a name="1029"><span class="lineNum">    1029 </span>            :   }</a>
<a name="1030"><span class="lineNum">    1030 </span>            : </a>
<a name="1031"><span class="lineNum">    1031 </span>            :   /*!</a>
<a name="1032"><span class="lineNum">    1032 </span>            :     * \brief Specialized method for loading Eigen matrix parameters with default value.</a>
<a name="1033"><span class="lineNum">    1033 </span>            :     *</a>
<a name="1034"><span class="lineNum">    1034 </span>            :     * This variant assumes that the matrix dimensions are known in compiletime.</a>
<a name="1035"><span class="lineNum">    1035 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1036"><span class="lineNum">    1036 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1037"><span class="lineNum">    1037 </span>            :     * the default value is used.</a>
<a name="1038"><span class="lineNum">    1038 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1039"><span class="lineNum">    1039 </span>            :     *</a>
<a name="1040"><span class="lineNum">    1040 </span>            :     * \tparam rows          Expected number of rows of the matrix.</a>
<a name="1041"><span class="lineNum">    1041 </span>            :     * \tparam cols          Expected number of columns of the matrix.</a>
<a name="1042"><span class="lineNum">    1042 </span>            :     *</a>
<a name="1043"><span class="lineNum">    1043 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1044"><span class="lineNum">    1044 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1045"><span class="lineNum">    1045 </span>            :     * \return              The loaded parameter value.</a>
<a name="1046"><span class="lineNum">    1046 </span>            :     *</a>
<a name="1047"><span class="lineNum">    1047 </span>            :     */</a>
<a name="1048"><span class="lineNum">    1048 </span>            :   template &lt;int rows, int cols, typename T, typename Derived&gt;</a>
<a name="1049"><span class="lineNum">    1049 </span>            :   Eigen::Matrix&lt;T, rows, cols&gt; loadMatrixStatic2(const std::string&amp; name, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value)</a>
<a name="1050"><span class="lineNum">    1050 </span>            :   {</a>
<a name="1051"><span class="lineNum">    1051 </span>            :     Eigen::Matrix&lt;T, rows, cols&gt; ret;</a>
<a name="1052"><span class="lineNum">    1052 </span>            :     loadMatrixStatic(name, ret, default_value);</a>
<a name="1053"><span class="lineNum">    1053 </span>            :     return ret;</a>
<a name="1054"><span class="lineNum">    1054 </span>            :   }</a>
<a name="1055"><span class="lineNum">    1055 </span>            :   //}</a>
<a name="1056"><span class="lineNum">    1056 </span>            : </a>
<a name="1057"><span class="lineNum">    1057 </span>            :   // loadMatrixKnown function for loading of Eigen matrices with known dimensions //{</a>
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<a name="1059"><span class="lineNum">    1059 </span>            :   /*!</a>
<a name="1060"><span class="lineNum">    1060 </span>            :     * \brief Specialized method for loading compulsory Eigen matrix parameters.</a>
<a name="1061"><span class="lineNum">    1061 </span>            :     *</a>
<a name="1062"><span class="lineNum">    1062 </span>            :     * This variant assumes that the matrix dimensions are known in runtime, but not compiletime.</a>
<a name="1063"><span class="lineNum">    1063 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1064"><span class="lineNum">    1064 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1065"><span class="lineNum">    1065 </span>            :     * the loading process is unsuccessful.</a>
<a name="1066"><span class="lineNum">    1066 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1067"><span class="lineNum">    1067 </span>            :     *</a>
<a name="1068"><span class="lineNum">    1068 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1069"><span class="lineNum">    1069 </span>            :     * \param mat   Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1070"><span class="lineNum">    1070 </span>            :     * \param rows  Expected number of rows of the matrix.</a>
<a name="1071"><span class="lineNum">    1071 </span>            :     * \param cols  Expected number of columns of the matrix.</a>
<a name="1072"><span class="lineNum">    1072 </span>            :     * \return      true if loaded successfully, false otherwise.</a>
<a name="1073"><span class="lineNum">    1073 </span>            :     */</a>
<a name="1074"><span class="lineNum">    1074 </span>            :   template &lt;typename T&gt;</a>
<a name="1075"><span class="lineNum">    1075 </span><span class="lineCov">        188 :   bool loadMatrixKnown(const std::string&amp; name, MatrixX&lt;T&gt;&amp; mat, int rows, int cols)</span></a>
<a name="1076"><span class="lineNum">    1076 </span>            :   {</a>
<a name="1077"><span class="lineNum">    1077 </span><span class="lineCov">        376 :     const auto [ret, loaded_ok] = loadMatrixKnown_internal(name, MatrixX&lt;T&gt;(), rows, cols, COMPULSORY, UNIQUE);</span></a>
<a name="1078"><span class="lineNum">    1078 </span><span class="lineCov">        188 :     mat = ret;</span></a>
<a name="1079"><span class="lineNum">    1079 </span><span class="lineCov">        376 :     return loaded_ok;</span></a>
<a name="1080"><span class="lineNum">    1080 </span>            :   }</a>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<a name="1082"><span class="lineNum">    1082 </span>            :   /*!</a>
<a name="1083"><span class="lineNum">    1083 </span>            :     * \brief Specialized method for loading Eigen matrix parameters with default value.</a>
<a name="1084"><span class="lineNum">    1084 </span>            :     *</a>
<a name="1085"><span class="lineNum">    1085 </span>            :     * This variant assumes that the matrix dimensions are known in runtime, but not compiletime.</a>
<a name="1086"><span class="lineNum">    1086 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1087"><span class="lineNum">    1087 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1088"><span class="lineNum">    1088 </span>            :     * the default value is used.</a>
<a name="1089"><span class="lineNum">    1089 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1090"><span class="lineNum">    1090 </span>            :     *</a>
<a name="1091"><span class="lineNum">    1091 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1092"><span class="lineNum">    1092 </span>            :     * \param mat           Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1093"><span class="lineNum">    1093 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1094"><span class="lineNum">    1094 </span>            :     * \param rows          Expected number of rows of the matrix.</a>
<a name="1095"><span class="lineNum">    1095 </span>            :     * \param cols          Expected number of columns of the matrix.</a>
<a name="1096"><span class="lineNum">    1096 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="1097"><span class="lineNum">    1097 </span>            :     */</a>
<a name="1098"><span class="lineNum">    1098 </span>            :   template &lt;typename T, typename Derived&gt;</a>
<a name="1099"><span class="lineNum">    1099 </span>            :   bool loadMatrixKnown(const std::string&amp; name, MatrixX&lt;T&gt;&amp; mat, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value, int rows, int cols)</a>
<a name="1100"><span class="lineNum">    1100 </span>            :   {</a>
<a name="1101"><span class="lineNum">    1101 </span>            :     const auto [ret, loaded_ok] = loadMatrixKnown_internal(name, MatrixX&lt;T&gt;(default_value), rows, cols, OPTIONAL, UNIQUE);</a>
<a name="1102"><span class="lineNum">    1102 </span>            :     mat = ret;</a>
<a name="1103"><span class="lineNum">    1103 </span>            :     return loaded_ok;</a>
<a name="1104"><span class="lineNum">    1104 </span>            :   }</a>
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<a name="1106"><span class="lineNum">    1106 </span>            :   /*!</a>
<a name="1107"><span class="lineNum">    1107 </span>            :     * \brief Specialized method for loading compulsory Eigen matrix parameters.</a>
<a name="1108"><span class="lineNum">    1108 </span>            :     *</a>
<a name="1109"><span class="lineNum">    1109 </span>            :     * This variant assumes that the matrix dimensions are known in runtime, but not compiletime.</a>
<a name="1110"><span class="lineNum">    1110 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1111"><span class="lineNum">    1111 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1112"><span class="lineNum">    1112 </span>            :     * the loading process is unsuccessful.</a>
<a name="1113"><span class="lineNum">    1113 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1114"><span class="lineNum">    1114 </span>            :     *</a>
<a name="1115"><span class="lineNum">    1115 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1116"><span class="lineNum">    1116 </span>            :     * \param rows  Expected number of rows of the matrix.</a>
<a name="1117"><span class="lineNum">    1117 </span>            :     * \param cols  Expected number of columns of the matrix.</a>
<a name="1118"><span class="lineNum">    1118 </span>            :     * \return      The loaded parameter value.</a>
<a name="1119"><span class="lineNum">    1119 </span>            :     */</a>
<a name="1120"><span class="lineNum">    1120 </span>            :   template &lt;typename T = double&gt;</a>
<a name="1121"><span class="lineNum">    1121 </span>            :   MatrixX&lt;T&gt; loadMatrixKnown2(const std::string&amp; name, int rows, int cols)</a>
<a name="1122"><span class="lineNum">    1122 </span>            :   {</a>
<a name="1123"><span class="lineNum">    1123 </span>            :     MatrixX&lt;T&gt; ret;</a>
<a name="1124"><span class="lineNum">    1124 </span>            :     loadMatrixKnown(name, ret, rows, cols);</a>
<a name="1125"><span class="lineNum">    1125 </span>            :     return ret;</a>
<a name="1126"><span class="lineNum">    1126 </span>            :   }</a>
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<a name="1128"><span class="lineNum">    1128 </span>            :   /*!</a>
<a name="1129"><span class="lineNum">    1129 </span>            :     * \brief Specialized method for loading Eigen matrix parameters with default value.</a>
<a name="1130"><span class="lineNum">    1130 </span>            :     *</a>
<a name="1131"><span class="lineNum">    1131 </span>            :     * This variant assumes that the matrix dimensions are known in runtime, but not compiletime.</a>
<a name="1132"><span class="lineNum">    1132 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1133"><span class="lineNum">    1133 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1134"><span class="lineNum">    1134 </span>            :     * the default value is used.</a>
<a name="1135"><span class="lineNum">    1135 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1136"><span class="lineNum">    1136 </span>            :     *</a>
<a name="1137"><span class="lineNum">    1137 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1138"><span class="lineNum">    1138 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1139"><span class="lineNum">    1139 </span>            :     * \param rows          Expected number of rows of the matrix.</a>
<a name="1140"><span class="lineNum">    1140 </span>            :     * \param cols          Expected number of columns of the matrix.</a>
<a name="1141"><span class="lineNum">    1141 </span>            :     * \return              The loaded parameter value.</a>
<a name="1142"><span class="lineNum">    1142 </span>            :     */</a>
<a name="1143"><span class="lineNum">    1143 </span>            :   template &lt;typename T, typename Derived&gt;</a>
<a name="1144"><span class="lineNum">    1144 </span>            :   MatrixX&lt;T&gt; loadMatrixKnown2(const std::string&amp; name, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value, int rows, int cols)</a>
<a name="1145"><span class="lineNum">    1145 </span>            :   {</a>
<a name="1146"><span class="lineNum">    1146 </span>            :     MatrixX&lt;T&gt; ret;</a>
<a name="1147"><span class="lineNum">    1147 </span>            :     loadMatrixKnown(name, ret, default_value, rows, cols);</a>
<a name="1148"><span class="lineNum">    1148 </span>            :     return ret;</a>
<a name="1149"><span class="lineNum">    1149 </span>            :   }</a>
<a name="1150"><span class="lineNum">    1150 </span>            :   //}</a>
<a name="1151"><span class="lineNum">    1151 </span>            : </a>
<a name="1152"><span class="lineNum">    1152 </span>            :   // loadMatrixDynamic function for half-dynamic loading of MatrixX&lt;T&gt; //{</a>
<a name="1153"><span class="lineNum">    1153 </span>            : </a>
<a name="1154"><span class="lineNum">    1154 </span>            :   /*!</a>
<a name="1155"><span class="lineNum">    1155 </span>            :     * \brief Specialized method for loading compulsory dynamic Eigen matrix parameters.</a>
<a name="1156"><span class="lineNum">    1156 </span>            :     *</a>
<a name="1157"><span class="lineNum">    1157 </span>            :     * This variant assumes that the only one of the matrix dimensions are known, the other is selected based on the loaded value.</a>
<a name="1158"><span class="lineNum">    1158 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1159"><span class="lineNum">    1159 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1160"><span class="lineNum">    1160 </span>            :     * the loading process is unsuccessful.</a>
<a name="1161"><span class="lineNum">    1161 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1162"><span class="lineNum">    1162 </span>            :     *</a>
<a name="1163"><span class="lineNum">    1163 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1164"><span class="lineNum">    1164 </span>            :     * \param mat   Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1165"><span class="lineNum">    1165 </span>            :     * \param rows  Expected number of rows of the matrix (negative value indicates that the number of rows is to be deduced from the specified number of columns and the size of the loaded array).</a>
<a name="1166"><span class="lineNum">    1166 </span>            :     * \param cols  Expected number of columns of the matrix (negative value indicates that the number of columns is to be deduced from the specified number of rows and the size of the loaded array).</a>
<a name="1167"><span class="lineNum">    1167 </span>            :     * \return      true if loaded successfully, false otherwise.</a>
<a name="1168"><span class="lineNum">    1168 </span>            :     */</a>
<a name="1169"><span class="lineNum">    1169 </span>            :   template &lt;typename T&gt;</a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineCov">         35 :   bool loadMatrixDynamic(const std::string&amp; name, MatrixX&lt;T&gt;&amp; mat, int rows, int cols)</span></a>
<a name="1171"><span class="lineNum">    1171 </span>            :   {</a>
<a name="1172"><span class="lineNum">    1172 </span><span class="lineCov">         70 :     const auto [ret, loaded_ok] = loadMatrixDynamic_internal(name, MatrixX&lt;T&gt;(), rows, cols, COMPULSORY, UNIQUE);</span></a>
<a name="1173"><span class="lineNum">    1173 </span><span class="lineCov">         35 :     mat = ret;</span></a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineCov">         70 :     return loaded_ok;</span></a>
<a name="1175"><span class="lineNum">    1175 </span>            :   }</a>
<a name="1176"><span class="lineNum">    1176 </span>            : </a>
<a name="1177"><span class="lineNum">    1177 </span>            :   /*!</a>
<a name="1178"><span class="lineNum">    1178 </span>            :     * \brief Specialized method for loading compulsory dynamic Eigen matrix parameters.</a>
<a name="1179"><span class="lineNum">    1179 </span>            :     *</a>
<a name="1180"><span class="lineNum">    1180 </span>            :     * This variant assumes that the only one of the matrix dimensions are known, the other is selected based on the loaded value.</a>
<a name="1181"><span class="lineNum">    1181 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1182"><span class="lineNum">    1182 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1183"><span class="lineNum">    1183 </span>            :     * the default value is used.</a>
<a name="1184"><span class="lineNum">    1184 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1185"><span class="lineNum">    1185 </span>            :     *</a>
<a name="1186"><span class="lineNum">    1186 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1187"><span class="lineNum">    1187 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1188"><span class="lineNum">    1188 </span>            :     * \param mat           Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1189"><span class="lineNum">    1189 </span>            :     * \param rows          Expected number of rows of the matrix (negative value indicates that the number of rows is to be deduced from the specified number of columns and the size of the loaded array).</a>
<a name="1190"><span class="lineNum">    1190 </span>            :     * \param cols          Expected number of columns of the matrix (negative value indicates that the number of columns is to be deduced from the specified number of rows and the size of the loaded array).</a>
<a name="1191"><span class="lineNum">    1191 </span>            :     * \return              true if the parameter was loaded from \p rosparam, false if the default value was used.</a>
<a name="1192"><span class="lineNum">    1192 </span>            :     */</a>
<a name="1193"><span class="lineNum">    1193 </span>            :   template &lt;typename T, typename Derived&gt;</a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineCov">         47 :   bool loadMatrixDynamic(const std::string&amp; name, MatrixX&lt;T&gt;&amp; mat, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value, int rows, int cols)</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            :   {</a>
<a name="1196"><span class="lineNum">    1196 </span><span class="lineCov">         94 :     const auto [ret, loaded_ok] = loadMatrixDynamic_internal(name, MatrixX&lt;T&gt;(default_value), rows, cols, OPTIONAL, UNIQUE);</span></a>
<a name="1197"><span class="lineNum">    1197 </span><span class="lineCov">         47 :     mat = ret;</span></a>
<a name="1198"><span class="lineNum">    1198 </span><span class="lineCov">         94 :     return loaded_ok;</span></a>
<a name="1199"><span class="lineNum">    1199 </span>            :   }</a>
<a name="1200"><span class="lineNum">    1200 </span>            : </a>
<a name="1201"><span class="lineNum">    1201 </span>            :   /*!</a>
<a name="1202"><span class="lineNum">    1202 </span>            :     * \brief Specialized method for loading compulsory dynamic Eigen matrix parameters.</a>
<a name="1203"><span class="lineNum">    1203 </span>            :     *</a>
<a name="1204"><span class="lineNum">    1204 </span>            :     * This variant assumes that the only one of the matrix dimensions are known, the other is selected based on the loaded value.</a>
<a name="1205"><span class="lineNum">    1205 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1206"><span class="lineNum">    1206 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1207"><span class="lineNum">    1207 </span>            :     * the loading process is unsuccessful.</a>
<a name="1208"><span class="lineNum">    1208 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1209"><span class="lineNum">    1209 </span>            :     *</a>
<a name="1210"><span class="lineNum">    1210 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1211"><span class="lineNum">    1211 </span>            :     * \param rows  Expected number of rows of the matrix (negative value indicates that the number of rows is to be deduced from the specified number of columns and the size of the loaded array).</a>
<a name="1212"><span class="lineNum">    1212 </span>            :     * \param cols  Expected number of columns of the matrix (negative value indicates that the number of columns is to be deduced from the specified number of rows and the size of the loaded array).</a>
<a name="1213"><span class="lineNum">    1213 </span>            :     * \return      The loaded parameter value.</a>
<a name="1214"><span class="lineNum">    1214 </span>            :     */</a>
<a name="1215"><span class="lineNum">    1215 </span>            :   template &lt;typename T = double&gt;</a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineCov">         35 :   MatrixX&lt;T&gt; loadMatrixDynamic2(const std::string&amp; name, int rows, int cols)</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            :   {</a>
<a name="1218"><span class="lineNum">    1218 </span><span class="lineCov">         35 :     MatrixX&lt;T&gt; ret;</span></a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineCov">         35 :     loadMatrixDynamic(name, ret, rows, cols);</span></a>
<a name="1220"><span class="lineNum">    1220 </span><span class="lineCov">         35 :     return ret;</span></a>
<a name="1221"><span class="lineNum">    1221 </span>            :   }</a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span>            :   /*!</a>
<a name="1224"><span class="lineNum">    1224 </span>            :     * \brief Specialized method for loading compulsory dynamic Eigen matrix parameters.</a>
<a name="1225"><span class="lineNum">    1225 </span>            :     *</a>
<a name="1226"><span class="lineNum">    1226 </span>            :     * This variant assumes that the only one of the matrix dimensions are known, the other is selected based on the loaded value.</a>
<a name="1227"><span class="lineNum">    1227 </span>            :     * If the dimensions of the loaded matrix do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1228"><span class="lineNum">    1228 </span>            :     * If the parameter with the specified name is not found on the rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1229"><span class="lineNum">    1229 </span>            :     * the default value is used.</a>
<a name="1230"><span class="lineNum">    1230 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1231"><span class="lineNum">    1231 </span>            :     *</a>
<a name="1232"><span class="lineNum">    1232 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1233"><span class="lineNum">    1233 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1234"><span class="lineNum">    1234 </span>            :     * \param rows          Expected number of rows of the matrix (negative value indicates that the number of rows is to be deduced from the specified number of columns and the size of the loaded array).</a>
<a name="1235"><span class="lineNum">    1235 </span>            :     * \param cols          Expected number of columns of the matrix (negative value indicates that the number of columns is to be deduced from the specified number of rows and the size of the loaded array).</a>
<a name="1236"><span class="lineNum">    1236 </span>            :     * \return              The loaded parameter value.</a>
<a name="1237"><span class="lineNum">    1237 </span>            :     */</a>
<a name="1238"><span class="lineNum">    1238 </span>            :   template &lt;typename T, typename Derived&gt;</a>
<a name="1239"><span class="lineNum">    1239 </span>            :   MatrixX&lt;T&gt; loadMatrixDynamic2(const std::string&amp; name, const Eigen::MatrixBase&lt;Derived&gt;&amp; default_value, int rows, int cols)</a>
<a name="1240"><span class="lineNum">    1240 </span>            :   {</a>
<a name="1241"><span class="lineNum">    1241 </span>            :     MatrixX&lt;T&gt; ret;</a>
<a name="1242"><span class="lineNum">    1242 </span>            :     loadMatrixDynamic(name, ret, default_value, rows, cols);</a>
<a name="1243"><span class="lineNum">    1243 </span>            :     return ret;</a>
<a name="1244"><span class="lineNum">    1244 </span>            :   }</a>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<a name="1246"><span class="lineNum">    1246 </span>            :   //}</a>
<a name="1247"><span class="lineNum">    1247 </span>            : </a>
<a name="1248"><span class="lineNum">    1248 </span>            :   // loadMatrixArray function for loading of an array of MatrixX&lt;T&gt; with known dimensions //{</a>
<a name="1249"><span class="lineNum">    1249 </span>            :   /*!</a>
<a name="1250"><span class="lineNum">    1250 </span>            :     * \brief Specialized method for loading compulsory parameters, interpreted as an array of dynamic Eigen matrices.</a>
<a name="1251"><span class="lineNum">    1251 </span>            :     *</a>
<a name="1252"><span class="lineNum">    1252 </span>            :     * The number of rows and columns of the matrices to be loaded is specified in the \c rosparam parameter. Specifically, the \c name/rows value specifies the</a>
<a name="1253"><span class="lineNum">    1253 </span>            :     * number of rows, which must be common to all the loaded matrices (i.e. it is one integer &gt;= 0), and the \c name/cols value specifies the number of columns of</a>
<a name="1254"><span class="lineNum">    1254 </span>            :     * each matrix (i.e. it is an array of integers &gt; 0). The \c name/data array contains the values of the elements of the matrices and it must have length</a>
<a name="1255"><span class="lineNum">    1255 </span>            :     * \f$ r\sum_i c_i \f$, where \f$ r \f$ is the common number of rows and \f$ c_i \f$ is the number of columns of the \f$ i \f$-th matrix.</a>
<a name="1256"><span class="lineNum">    1256 </span>            :     * A typical structure of a \c yaml file, specifying the</a>
<a name="1257"><span class="lineNum">    1257 </span>            :     * matrix array to be loaded using this method, is</a>
<a name="1258"><span class="lineNum">    1258 </span>            :     *</a>
<a name="1259"><span class="lineNum">    1259 </span>            :     * \code{.yaml}</a>
<a name="1260"><span class="lineNum">    1260 </span>            :     *</a>
<a name="1261"><span class="lineNum">    1261 </span>            :     * matrix_array:</a>
<a name="1262"><span class="lineNum">    1262 </span>            :     *   rows: 3</a>
<a name="1263"><span class="lineNum">    1263 </span>            :     *   cols: [1, 2]</a>
<a name="1264"><span class="lineNum">    1264 </span>            :     *   data: [-5.0, 0.0, 23.0,</a>
<a name="1265"><span class="lineNum">    1265 </span>            :     *          -5.0, 0.0, 12.0,</a>
<a name="1266"><span class="lineNum">    1266 </span>            :     *           2.0,   4.0,  7.0]</a>
<a name="1267"><span class="lineNum">    1267 </span>            :     *</a>
<a name="1268"><span class="lineNum">    1268 </span>            :     * \endcode</a>
<a name="1269"><span class="lineNum">    1269 </span>            :     *</a>
<a name="1270"><span class="lineNum">    1270 </span>            :     * which will be loaded as a \c std::vector, containing one \f$ 3\times 1 \f$ matrix and one \f$ 3\times 2 \f$ matrix.</a>
<a name="1271"><span class="lineNum">    1271 </span>            :     *</a>
<a name="1272"><span class="lineNum">    1272 </span>            :     * If the dimensions of the loaded matrices do not match the specified number of rows and columns, the loading process is unsuccessful (loaded_successfully() will return false).</a>
<a name="1273"><span class="lineNum">    1273 </span>            :     * If the parameter with the specified name is not found on the \c rosparam server (e.g. because it is not specified in the launchfile or yaml config file),</a>
<a name="1274"><span class="lineNum">    1274 </span>            :     * the loading process is unsuccessful.</a>
<a name="1275"><span class="lineNum">    1275 </span>            :     * Using this method, the parameter can only be loaded once using the same ParamLoader instance without error.</a>
<a name="1276"><span class="lineNum">    1276 </span>            :     *</a>
<a name="1277"><span class="lineNum">    1277 </span>            :     * \param name  Name of the parameter in the rosparam server.</a>
<a name="1278"><span class="lineNum">    1278 </span>            :     * \param mat   Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1279"><span class="lineNum">    1279 </span>            :     *</a>
<a name="1280"><span class="lineNum">    1280 </span>            :     */</a>
<a name="1281"><span class="lineNum">    1281 </span>            :   template &lt;typename T&gt;</a>
<a name="1282"><span class="lineNum">    1282 </span>            :   void loadMatrixArray(const std::string&amp; name, std::vector&lt;MatrixX&lt;T&gt;&gt;&amp; mat)</a>
<a name="1283"><span class="lineNum">    1283 </span>            :   {</a>
<a name="1284"><span class="lineNum">    1284 </span>            :     mat = loadMatrixArray2&lt;double&gt;(name);</a>
<a name="1285"><span class="lineNum">    1285 </span>            :   }</a>
<a name="1286"><span class="lineNum">    1286 </span>            : </a>
<a name="1287"><span class="lineNum">    1287 </span>            :   /*!</a>
<a name="1288"><span class="lineNum">    1288 </span>            :     * \brief Specialized method for loading compulsory parameters, interpreted as an array of dynamic Eigen matrices.</a>
<a name="1289"><span class="lineNum">    1289 </span>            :     *</a>
<a name="1290"><span class="lineNum">    1290 </span>            :     * This overload of the loadMatrixArray() method takes a default value for the parameter, which is used in case a \c rosparam with the specified name is not</a>
<a name="1291"><span class="lineNum">    1291 </span>            :     * found in the \c rosparam server, instead of causing an unsuccessful load. This makes specifying the parameter value in the \c rosparam server optional.</a>
<a name="1292"><span class="lineNum">    1292 </span>            :     *</a>
<a name="1293"><span class="lineNum">    1293 </span>            :     * \param name           Name of the parameter in the rosparam server.</a>
<a name="1294"><span class="lineNum">    1294 </span>            :     * \param mat            Reference to the variable to which the parameter value will be stored (such as a class member variable).</a>
<a name="1295"><span class="lineNum">    1295 </span>            :     * \param default_value  The default value to be used in case the parameter is not found on the \c rosparam server.</a>
<a name="1296"><span class="lineNum">    1296 </span>            :     *</a>
<a name="1297"><span class="lineNum">    1297 </span>            :     */</a>
<a name="1298"><span class="lineNum">    1298 </span>            :   template &lt;typename T&gt;</a>
<a name="1299"><span class="lineNum">    1299 </span>            :   void loadMatrixArray(const std::string&amp; name, std::vector&lt;MatrixX&lt;T&gt;&gt;&amp; mat, const std::vector&lt;MatrixX&lt;T&gt;&gt;&amp; default_value)</a>
<a name="1300"><span class="lineNum">    1300 </span>            :   {</a>
<a name="1301"><span class="lineNum">    1301 </span>            :     mat = loadMatrixArray2(name, default_value);</a>
<a name="1302"><span class="lineNum">    1302 </span>            :   }</a>
<a name="1303"><span class="lineNum">    1303 </span>            : </a>
<a name="1304"><span class="lineNum">    1304 </span>            :   /*!</a>
<a name="1305"><span class="lineNum">    1305 </span>            :     * \brief Specialized method for loading compulsory parameters, interpreted as an array of dynamic Eigen matrices.</a>
<a name="1306"><span class="lineNum">    1306 </span>            :     *</a>
<a name="1307"><span class="lineNum">    1307 </span>            :     * This method works in the same way as the loadMatrixArray() method for compulsory parameters, except that the loaded</a>
<a name="1308"><span class="lineNum">    1308 </span>            :     * parameter is returned and not stored in the reference parameter.</a>
<a name="1309"><span class="lineNum">    1309 </span>            :     *</a>
<a name="1310"><span class="lineNum">    1310 </span>            :     * \param name           Name of the parameter in the rosparam server.</a>
<a name="1311"><span class="lineNum">    1311 </span>            :     * \returns              The loaded parameter or a default constructed object of the respective type.</a>
<a name="1312"><span class="lineNum">    1312 </span>            :     *</a>
<a name="1313"><span class="lineNum">    1313 </span>            :     */</a>
<a name="1314"><span class="lineNum">    1314 </span>            :   template &lt;typename T = double&gt;</a>
<a name="1315"><span class="lineNum">    1315 </span>            :   std::vector&lt;MatrixX&lt;T&gt;&gt; loadMatrixArray2(const std::string&amp; name)</a>
<a name="1316"><span class="lineNum">    1316 </span>            :   {</a>
<a name="1317"><span class="lineNum">    1317 </span>            :     return loadMatrixArray_internal(name, std::vector&lt;MatrixX&lt;T&gt;&gt;(), COMPULSORY, UNIQUE);</a>
<a name="1318"><span class="lineNum">    1318 </span>            :   }</a>
<a name="1319"><span class="lineNum">    1319 </span>            : </a>
<a name="1320"><span class="lineNum">    1320 </span>            :   /*!</a>
<a name="1321"><span class="lineNum">    1321 </span>            :     * \brief Specialized method for loading compulsory parameters, interpreted as an array of dynamic Eigen matrices.</a>
<a name="1322"><span class="lineNum">    1322 </span>            :     *</a>
<a name="1323"><span class="lineNum">    1323 </span>            :     * This method works in the same way as the loadMatrixArray() method for optional parameters, except that the loaded</a>
<a name="1324"><span class="lineNum">    1324 </span>            :     * parameter is returned and not stored in the reference parameter.</a>
<a name="1325"><span class="lineNum">    1325 </span>            :     *</a>
<a name="1326"><span class="lineNum">    1326 </span>            :     * \param name           Name of the parameter in the rosparam server.</a>
<a name="1327"><span class="lineNum">    1327 </span>            :     * \param default_value  The default value to be used in case the parameter is not found on the \c rosparam server.</a>
<a name="1328"><span class="lineNum">    1328 </span>            :     * \returns              The loaded parameter or the default value.</a>
<a name="1329"><span class="lineNum">    1329 </span>            :     *</a>
<a name="1330"><span class="lineNum">    1330 </span>            :     */</a>
<a name="1331"><span class="lineNum">    1331 </span>            :   template &lt;typename T&gt;</a>
<a name="1332"><span class="lineNum">    1332 </span>            :   std::vector&lt;MatrixX&lt;T&gt;&gt; loadMatrixArray2(const std::string&amp; name, const std::vector&lt;MatrixX&lt;T&gt;&gt;&amp; default_value)</a>
<a name="1333"><span class="lineNum">    1333 </span>            :   {</a>
<a name="1334"><span class="lineNum">    1334 </span>            :     return loadMatrixArray_internal(name, default_value, OPTIONAL, UNIQUE);</a>
<a name="1335"><span class="lineNum">    1335 </span>            :   }</a>
<a name="1336"><span class="lineNum">    1336 </span>            :   //}</a>
<a name="1337"><span class="lineNum">    1337 </span>            : </a>
<a name="1338"><span class="lineNum">    1338 </span>            :   //}</a>
<a name="1339"><span class="lineNum">    1339 </span>            : </a>
<a name="1340"><span class="lineNum">    1340 </span>            : };</a>
<a name="1341"><span class="lineNum">    1341 </span>            : //}</a>
<a name="1342"><span class="lineNum">    1342 </span>            : </a>
<a name="1343"><span class="lineNum">    1343 </span>            :   /*!</a>
<a name="1344"><span class="lineNum">    1344 </span>            :     * \brief An overload for loading ros::Duration.</a>
<a name="1345"><span class="lineNum">    1345 </span>            :     *</a>
<a name="1346"><span class="lineNum">    1346 </span>            :     * The duration will be loaded as a \p double, representing a number of seconds, and then converted to ros::Duration.</a>
<a name="1347"><span class="lineNum">    1347 </span>            :     *</a>
<a name="1348"><span class="lineNum">    1348 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1349"><span class="lineNum">    1349 </span>            :     * \param default_value This value will be used if the parameter name is not found in the rosparam server.</a>
<a name="1350"><span class="lineNum">    1350 </span>            :     * \return              The loaded parameter value.</a>
<a name="1351"><span class="lineNum">    1351 </span>            :     */</a>
<a name="1352"><span class="lineNum">    1352 </span>            :   template &lt;&gt;</a>
<a name="1353"><span class="lineNum">    1353 </span>            :   ros::Duration ParamLoader::loadParam2&lt;ros::Duration&gt;(const std::string&amp; name, const ros::Duration&amp; default_value);</a>
<a name="1354"><span class="lineNum">    1354 </span>            : </a>
<a name="1355"><span class="lineNum">    1355 </span>            :   /*!</a>
<a name="1356"><span class="lineNum">    1356 </span>            :     * \brief An overload for loading ros::Duration.</a>
<a name="1357"><span class="lineNum">    1357 </span>            :     *</a>
<a name="1358"><span class="lineNum">    1358 </span>            :     * The duration will be loaded as a \p double, representing a number of seconds, and then converted to ros::Duration.</a>
<a name="1359"><span class="lineNum">    1359 </span>            :     *</a>
<a name="1360"><span class="lineNum">    1360 </span>            :     * \param name          Name of the parameter in the rosparam server.</a>
<a name="1361"><span class="lineNum">    1361 </span>            :     * \return              The loaded parameter value.</a>
<a name="1362"><span class="lineNum">    1362 </span>            :     */</a>
<a name="1363"><span class="lineNum">    1363 </span>            :   template &lt;&gt;</a>
<a name="1364"><span class="lineNum">    1364 </span>            :   ros::Duration ParamLoader::loadParam2&lt;ros::Duration&gt;(const std::string&amp; name);</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            : }  // namespace mrs_lib</a>
<a name="1367"><span class="lineNum">    1367 </span>            : </a>
<a name="1368"><span class="lineNum">    1368 </span>            : #endif  // PARAM_LOADER_H</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
